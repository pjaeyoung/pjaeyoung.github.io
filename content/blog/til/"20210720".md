---
title: '20210720'
date: 2021-07-20 22:07:22
category: til
thumbnail: { thumbnailSrc }
draft: false
---

## 코딩테스트 준비

자료구조 힙(heap)을 알게 되었다. 힙은 우선순위 큐를 구현을 위한 이진트리다.
큐는 처음에 들어온 값이 먼저 나가는 구조지만 우선순위 큐는 우선순위가 높은 순으로 먼저 나간다.
힙은 최대힙과 최소힙 두 종류로 나뉜다. 최대힙은 부모노드가 자식노드보다 크거나 같은 값을 가지는 형태고
최소힙은 부모노드가 자식노드보다 작거나 큰 값을 가진 형태다.
힙은 배열을 이용하여 구현한다. 값 비교를 용이하게 하기 위해 0번째는 null로 처리하고 1번째 부터 값을 추가하는 것이 일반적이다.
1부터 차례대로 부모, 자식노드 위치를 매기면 다음과 같은 규칙이 나온다.

> 부모 노드 : Math.floor(index/2)  
> 왼쪽 자식 노드 : index \* 2  
> 오른쪽 자식 노드 : index \* 2 + 1

최대힙을 자바스크립트로 구현하면 다음과 같다.

```js
function MaxHeap() {
  // 0번째는 null을 추가한다. 실제로 값 비교는 1번째부터 진행된다.
  this.heap = [null]

  const getParentNodeIndex = index => {
    return Math.floor(index / 2)
  }

  const getParentNode = index => {
    return this.heap[getParentNodeIndex(index)]
  }

  this.insert = value => {
    // 제일 마지막에 값을 추가한다.
    this.heap.push(value)
    // 트리 순회를 거슬러 올라가기 위한 index
    // 방금 삽입한 값의 위치(제일 마지막 위치)를 최초로 할당한다.
    let index = this.heap.length - 1
    // index가 최상위 부모노드가 아니고 삽입한 value가 부모 노드보다 클 경우에만 순회한다
    while (index > 1 && value > getParentNode(index)) {
      // 부모노드와 자식노드의 값을 swap한다.
      this.heap[index] = getParentNode(index)
      this.heap[getParentNodeIndex(index)] = value
      index = getParentNodeIndex(index)
    }
  }

  // null이 들어있는 0번째 요소를 제외한 실제 값들이 들어있는 부분만 반환한다.
  this.print = () => {
    return this.heap.slice(1)
  }
}
```

## 스캡 프로젝트 다듬기 위한 준비

redux 에서 createAsyncThunk 문서를 천천히 읽으면서 사용법을 제대로 익히려고 노력하는 중이다.
프로젝트 중에 미쳐 보지 못하고 넘어간 개념들을 나열하면 이렇다.

- createAsyncThunk를 생성했다고 곧바로 store에서 관리하지 않는다. extraReducer에 직접 state별로(fulfilled, pending, rejected) state를 어떻게 처리할 지 정의해줘야 한다.
- typescript를 쓴다면 extraReducer에 작성할 때 builder를 쓰길 권장한다. ( 스캡에는 그렇게 안 쓰고 key-value 형태로 작성했다. 어쩐지 key값에서 타입에러가 나더라.)
- 비동기 dispatch할 때 fulfilled 든 rejected든 then으로 결과를 전달한다. 만약 rejected 결과는 catch문으로 전달하고 싶다면 then 처리 전에 unwrap 메서드를 실행하면 된다.
- rejectWithValue의 쓰임새를 잘 몰라서 여러 번 읽어 겨우 이해했다. 비동기 처리 말고 그 사이에 일어나는 동기처리에서 오류가 발생하는 케이스 또한 reject로 분류하고 싶을 때 쓴다. 특이한 점은 rejectWithValue에 담은 값은 action.payload에 들어간다. 직접 reject하지 않은 오류는 action.error에 들어있다.
  그래서 아래처럼 분기 처리가 필요하다.

```ts
 extraReducers: (builder) => {
    builder
      .addCase(fetchUserById.pending, (state) => {
        state.loading = LOADING.PENDING;
        state.error = null;
        state.entity = null;
      })
      .addCase(fetchUserById.fulfilled, (state, action) => {
        state.loading = LOADING.SUCCESS;
        state.entity = action.payload;
      })
      .addCase(fetchUserById.rejected, (state, action) => {
        state.loading = LOADING.FAIL;
        // rejectWithValue를 통해 값이 들어왔을 경우
        if (action.payload) {
          state.error = action.payload;
          return;
        }
        // 그 외의 경우
        state.error = action.error?.message ?? "유저 정보 요청 실패";
      });
  },
```

## 면접 준비

Q. localStorage, sessionStorage, cookie에 대해 설명하시오.
로그인 유무나 팝업창 일주일 간 닫기 여부, 추천 카테고리 등을 브라우저 차원에서 관리하는 데이터가 존재한다.
이러한 데이터를 보관할 때 사용하는 것이 로컬스토리지와 세션스토리지와 같은 웹스토리지와 쿠키다. 세 방식 모두 키 - 값 형태로 데이터를 저장한다.
HTML5 부터 도입된 웹스토리지 이전까지는 이 역할을 쿠키가 담당했었는데 쿠키는 4kb의 작은 용량에다 항상 HTTP의 헤더와 함께
서버로 전송이 되어 서버에 불필요한 데이터까지 보내는 낭비가 일어난다. 웹스토리지는 쿠키와 달리 서버로 자동으로 전송되지 않고 5mb정도로
쿠키보다 용량이 크다. 로컬스토리지와 세션스토리지의 차이는 영속성에 있다. 로컬스토리지는 사용자가 지우지 않는 한 계속 남아있는 반면 세션스토리지는
브라우저 탭이 닫히면 데이터가 사라진다.
