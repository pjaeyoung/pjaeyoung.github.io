---
title: '20210818'
date: 2021-08-19 00:08:73
category: naver-special-intensive-class
thumbnail: { thumbnailSrc }
draft: false
---

## 프로젝트 개선

### Redux가 잘 안 되던 이유

- 새로 작성했던 redux store를 provider로 제공하지 않았다. (나의 실수)
- 그리고 예전 redux store 를 넘기는 Provider와 같이 사용하면 작동이 되지 않는다는 걸 알게 되었다.
- 결국 redux-persist 문제가 아닌 것을 알았다.

### redux-persist 적용하기

- 어제와 마찬가지로 reducer안에서 AsyncStorage를 사용하던 코드를 걷어냈다.
- 코드가 한결 깔끔해졌다. 방어코드가 순환회로를 보이는 현상이 없어졌다.

```ts
// src/shared/store/folderSlice.ts
export const createUserFolder = createAsyncThunk<
  IStoredFolder,
  IFolder,
  {
    dispatch: AppDispatch
    rejectValue: IError
  }
>('folders/createUserFolder', async (folder, thunkAPI) => {
  try {
    // 파일시스템만 에러처리를 하고 곧바로 redux store에 새 state를 반영하기만 하면 된다.
    await FS.createFolder(folder.name)
    return { ...folder, id: uuidv1() }
  } catch {
    return thunkAPI.rejectWithValue({
      errorMessage: '내장메모리에 폴더 생성이 실패했습니다',
    })
  }
})
```

- React Native에서 redux-persist를 적용하려면 아래처럼 설정해줘야 한다. (공식문서 참고)

```ts
// src/shared/store/index.ts
import { configureStore, combineReducers } from '@reduxjs/toolkit'
import {
  persistStore,
  persistReducer,
  FLUSH,
  REHYDRATE,
  PAUSE,
  PERSIST,
  PURGE,
  REGISTER,
} from 'redux-persist'
import AsyncStorage from '@react-native-async-storage/async-storage'

import folderReducer from './folderSlice'
// React Native는 AsyncStorage를 사용하기 때문에 특별히 지정해줘야 한다.
const persistConfig = {
  key: 'root',
  storage: AsyncStorage,
}

const rootReducer = combineReducers({ folders: folderReducer })

const persistedReducer = persistReducer(persistConfig, rootReducer)
// redux-persist에서 사용하는 actions를 무시하도록 설정해야 한다.
// 원래 redux action에는 Non-Serializable Data(Promise, Map/Set 등)을 사용하지 말라고 하나
// 예외를 두고 싶다면 아래처럼 작성해야 한다. redux-persist가 Non-Serializable Data를 action으로 사용하고 있다는 걸 추측할 수 있다.
const store = configureStore({
  reducer: persistedReducer,
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
      },
    }),
})

export const persistor = persistStore(store)

export default store

export * from './folderSlice'
```

- AsyncStorage에 저장된 state를 삭제하려면 `persistor.purge()` 를 실행하면 된다. 저 코드가 무슨 의미인지 곧바로 해석하기 힘들어서 custom hook에 `clearAllUserFolders` 함수로 감싸서 내보내기 했다.

```ts
const useUserFolders = () => {
  /* 생략 */
  const clearAllUserFolders = () => {
    return persistor.purge()
  }

  return {
    userFolders: entries,
    loading,
    error,
    addUserFolder,
    clearAllUserFolders,
  }
}
```

- `clearAllUserFolders`를 실행하면 extraReducer의 PURGE action으로 들어온다.

```ts
const folderSlice = createSlice({
  name: 'folders',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder.addCase(PURGE, state => {
      // userFolders 초기화 처리
      state.entries = []
    })
  },
})
```

### 고민 - 폴더 생성과 수정 복잡성 완화하기

- 기존에는 생성과 수정을 한 컴포넌트 내에서 처리하다보니 복잡한 코드가 나왔다.
- 기존 코드는 수정용폴더 컴포넌트를 따로 만들었고 수정모드나 생성모드일 때 생성/수정할 위치에 수정용폴더 컴포넌트를 렌더링하는 식으로 구현했다. 생성일 때는 괜찮은데 수정모드일 때는 컴포넌트가 두 개 겹쳐서 렌더링한다는 문제가 있음. 겉 동작은 괜찮지만 실제로는 이상하다
- 또, 기존코드는 생성한 폴더 개수만큼 map 메서드를 사용해 렌더링하게 했다. 이부분 때문에 폴더 컴포넌트 자체에 input창을 on/off하는 대신 수정용폴더 컴포넌트를 따로 썼다. 이 과정에서 엄청난 폴더 렌더링 현상이 일어났다. input값 변화를 상위 컴포넌트에서 제어를 했기 때문이다. 그래서 수정용폴더 컴포넌트에만 input값 변화가 일어나도록 범위를 좁혔다.
- 기존코드의 복잡성을 줄일 수 있는 방법을 3가지 생각해봤다.
  - 생성모드, 수정모드, 모드 아닌 경우를 각각 나누어 처리하는 방법
  - 생성/수정모드 , 모드 아닌 경우를 나누어 처리하는 방법
  - 세 개를 다 합하는 방법
- 마지막 방법은 미리 폴더컴포넌트들을 다 생성하고 redux에 저장된 폴더 개수만큼만 visible하게 바꾼다. 수정/생성모드에 진입시 폴더 인덱스 위치에 있는 폴더컴포넌트의 input창을 활성화한다. 위 두 방법이 거의 유사한 화면인데 여러 개를 구현하는 소모적인 일이 될 것 같아서 마지막 방법을 적용해볼 생각이다.
