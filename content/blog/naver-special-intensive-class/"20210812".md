---
title: '20210812'
date: 2021-08-12 23:08:36
category: naver-special-intensive-class
thumbnail: { thumbnailSrc }
draft: false
---

## 알고리즘

유클리드 호제법을 사용해 최대공약수를 구하는 방법을 알게 되었다.  
유클리드 호제법은 큰 수를 작은 수로 나눴을 때 그 나머지가 0이 되면 작은 수가 곧 최대공약수가 된다는 공식이다. 구현 내용은 아래와 같다.

```js
// b는 a보다 크다고 가정
function gcd(a, b) {
  while (a > 0) {
    const remain = b % a
    b = a
    a = remain
  }

  return b
}
```

## 프로젝트 개선

### FolderScreen 컴포넌트 계층 구조

![스크린샷, 2021-08-12 15-28-14](https://user-images.githubusercontent.com/47022167/129148465-ba924c84-2caa-47c6-807b-d306181c738c.png)

- FolderScreen 안에 renderScrollable을 받는 구조는 Onboarding 화면에서 `<FolderScreen renderScrollable={renderScrollable}/>` 로 작성해야 한다. 그러면 OnboardingScreen 안에 또 스크린이? 라는 의문이 생긴다. (액자식 구조도 아니고...)
- 그래서 FolderScreen을 한 층 더 상위 컴포넌트로 올리고 내부에 renderScrollable을 props로 받는 KeyboardAccessoryView 컴포넌트를 렌더링 하도록 했다. 이렇게 하면 Onboarding화면에서도 `<KeyboardAccessoryView renderScrollable={renderScrollable}/>` 로 렌더링하면 된다. 좀더 컴포넌트를 들고 온다는 의미가 잘 전달된다.
- Alert 컴포넌트는 원래 renderScrollable에 속했는데 다른 화면에서도 사용되는 컴포넌트니 위로 올렸다. 현재 Alert는 상위 컴포넌트의 state로 제어를 하는 형태다. 어느 아티클에서 다른 방식으로 다룬 코드를 봤다. redux 비동기 처리후 alert를 dispatch하여 실행하는 방식이다. 이렇게 하면 Alert를 사용하는 각 컴포넌트에 state를 생성하는 번거로움을 줄이고 redux에서 비동기든 상관없이 alert를 제어할 수 있어 편리하다. 구체적인 로직은 다음에 세울 생각이다.
- UserFolders와 CreateFolderMessage 는 모두 userFolders 상태에 영향을 받는다. 공통으로 사용되는 상태를 항상 상위 컴포넌트에서 내려주는 방식을 택했는데, renderScrollable의 경우 userFolders와 관련이 없는 여러 컴포넌트들이 같이 있어서 매번 새로 렌더링이 일어나는 문제가 있었다. 그래서 UserFolders를 컴포넌트로 분리하고 UserFolders와 CreateFolderMessage 각자 내부적으로 userFolders값에 따라 렌더링을 어떻게 처리할 지 하는 방식으로 관심사를 좁힐 계획이다.
- AccessoryItem과 UserFolders에서 공통으로 color와 folderName 상태에 영향을 받는다. 두 상태는 FolderScreen 화면에 국한되어 사용하기 때문에 redux까지 도입할 필요성을 못 느꼈다. redux는 여러 스크린에 영향을 주는 글로벌 상태만 두는 게 맞으니 부분 적으로 여러 컴포넌트에 같이 사용되는 상태는 Context로 관리하기로 했다. 두 상태도 이전에 가장 상위컴포넌트인 FolderScreen에서 관리했으나 renderScrollable과 FolderScreen화면을 번갈아 가면서 상태 변화 흐름을 파악해야 하는 번거로움과 어려움이 있었다. 그래서 이번엔 영향을 받는 바로 그 컴포넌트만 확인하는 방식을 적용하고 싶었다.

### ContextAPI 적용

- [How to use React Context effectively](https://kentcdodds.com/blog/how-to-use-react-context-effectively) 아티클을 참고해서 folder과 color 상태를 관리하도록 했다. 일단 Accessory 부분은 잘 작동되는 것을 확인했다. 아래는 작성한 코드다.

- 커스텀 Provider 생성

```ts
// FolderNameContext.tsx
// color도 거의 똑같은 구성으로 되어있다.
import * as React from 'react'

const FolderNameStateContext = React.createContext<string>('')
const FolderNameDispatchContext = React.createContext<
  React.Dispatch<React.SetStateAction<string>>
>(() => undefined)

const FolderNameProvider: React.FC = ({ children }) => {
  const [folderName, setFolderName] = React.useState('')
  return (
    <FolderNameStateContext.Provider value={folderName}>
      <FolderNameDispatchContext.Provider value={setFolderName}>
        {children}
      </FolderNameDispatchContext.Provider>
    </FolderNameStateContext.Provider>
  )
}

function useFolderNameState(): string {
  const context = React.useContext(FolderNameStateContext)
  return context
}

function useFolderNameDispatch(): React.Dispatch<React.SetStateAction<string>> {
  const context = React.useContext(FolderNameDispatchContext)
  return context
}

export { FolderNameProvider, useFolderNameState, useFolderNameDispatch }
```

- 커스텀 Provider 적용

```ts
// KeyboardAccessoryView.tsx
import * as React from 'react'
import { GestureResponderHandlers } from 'react-native'

import { KeyboardAccessoryView } from '@flyerhq/react-native-keyboard-accessory-view'
import KeywordAccessoryList from './KeywordAccessoryList'
import ColorAccessoryList from './ColorAccessoryList'

import { FolderNameProvider } from '../context/FolderNameContext'
import { ColorProvider } from '../context/ColorContext'

interface IKeyboardAccessoryViewWrapperProps {
  renderScrollable: (panHandlers: GestureResponderHandlers) => React.ReactNode
}

// 이름이 중복되어 Wrapper를 덧붙였다.
const KeyboardAccessoryViewWrapper: React.FC<IKeyboardAccessoryViewWrapperProps> = ({
  renderScrollable,
}) => {
  return (
    <FolderNameProvider>
      <ColorProvider>
        <KeyboardAccessoryView renderScrollable={renderScrollable}>
          <KeywordAccessoryList />
          <ColorAccessoryList />
        </KeyboardAccessoryView>
      </ColorProvider>
    </FolderNameProvider>
  )
}

export default KeyboardAccessoryViewWrapper
```

- context 사용

```ts
import * as React from 'react'
import KeywordAccessoryItem from './KeywordAccessoryItem'
import { keywords } from '../constants'

import styled from '@emotion/native'
import { useFolderNameDispatch } from '../context/FolderNameContext'

const KeywordAccessoryList: React.FC = () => {
  const lastIndex = keywords.length - 1
  const setFolderName = useFolderNameDispatch()
  const onPressKeywordAccessoryItem = (keyword: string) => () => {
    setFolderName(keyword)
  }
  return (
    <KeyboardAccessoryItem keyboardShouldPersistTaps="handled" horizontal>
      {keywords.map((keyword, index) => (
        <KeywordAccessoryItem
          key={index}
          name={keyword}
          isLast={index === lastIndex}
          onPress={onPressKeywordAccessoryItem(keyword)}
        />
      ))}
    </KeyboardAccessoryItem>
  )
}

export default KeywordAccessoryList

const KeyboardAccessoryItem = styled.ScrollView({
  backgroundColor: '#e4e7e8',
  height: 45,
})
```
