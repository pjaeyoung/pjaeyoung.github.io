---
title: '20210813'
date: 2021-08-13 23:08:07
category: naver-special-intensive-class
thumbnail: { thumbnailSrc }
draft: false
---

## Daily 회고

:small_orange_diamond: 오늘 한 일

- 코딩테스트에서 1문제만 풀었다. 나머지 두 문제는 아이디어는 있었으나 구현을 어떻게 해야 해서 막혔다.
- 크루분께 프로젝트 리뷰를 받았다.
- 프로젝트 모의면접을 진행했다.

:small_orange_diamond: 느낀 점

- 알고리즘 공부와 코딩테스트 연습을 거의 안 했더니 탈탈 털린 것 같다. 3주안에 드라마틱한 실력을 올릴 수 있을 거라 장담은 못하겠다. 말씀주신 것처럼 전략적으로 공부해야겠다.
- 프로젝트 리뷰에서 많은 도움을 받았다. 앱을 개발했는데 프론트엔드로 지원하는 까닭에 대해서 질문을 주셨다. React를 사용했으니 웹개발에도 문제가 없을 거다고 답변했는데 좋지 않은 답변이었다. '모바일 퍼스트'라는 키워드로 앱개발을 어떻게 웹개발과 연관을 지을지가 관건이라 말씀주셨다. 수료 직전 파이널 프로젝트에서 받지 못한 실질적인 조언들을 얻을 수 있었다. 미리 들었으면 좋았을텐데 하고 아쉬운 마음이 들지만 남은 3주에 최선을 다해 적용해보자.

:small_orange_diamond: 현재 나의 상태

- 프로젝트 모의면접을 두 번이나 봤다....아....갑자기 화면이 먹통이 되는 바람에 녹화본이 날라갔기 때문이다. 프로젝트 개선 시간에 모의 면접을 다시 진행해준 페어분들께 정말 미안했고 고마웠다ㅠㅠ
- 오전에는 코딩테스트 때문에 기분이 저조했는데 프로젝트 리뷰를 받으면서 내가 어떤 점이 부족한지 확실히 알았다. 따끔한 조언이 아프기보다는 더 잘해야겠다는 동기부여가 되었다.

## 프로젝트 개선 진행상황

## 태스크

- 코드 재사용성 - 폴더화면
- fix 버그 : 폴더 생성 / 수정

## 세부 태스크

- [ ] FolderScreen의 renderScrollable 컴포넌트 작은 단위로 쪼개기

## 작업과정

### Clean Code를 위한 Eslint rules 적용

- 개발자는 항상 깔끔한 코드를 작성하고 네이밍을 규칙에 따라 작성하는 건 당연하다. 하지만 사람인 이상 관성에 따라 그 규칙을 무시하는 경우가 생기는데 이부분을 어떻게 강제할까 문득 고민이 들어 Eslint 와 cleancode를 연관 검색어로 검색해봤다. 늘 그렇듯 나보다 먼저 그런 생각을 하신 분이 계셨다. plugin으로 만들었는데 굳이 npm으로 설치할 필요까진 없을 것 같아서 설정파일 중에 괜찮은 것을 골라 복사붙여넣기했다.
- 특히 좋았던 건 naming convention이다. boolean형과 같은 변수명을 지을 때 천차만별로 지을 거다. 그런데 prefix로 허용되는 문자들을 지정하면 그 외의 변수명은 에러를 내준다! (wow)
- 하지만 단수, 복수일 때 prefix로 'a'를 붙이거나 suffix로 's'를 붙일 수 있도록 커스터마이징까지는 못한다. 그게 좀 아쉽다.

```js
{
    'max-depth': ['error', 3],
    'max-params': ['error', 3],
    '@typescript-eslint/naming-convention': [
      'error',
      {
        selector: 'default',
        format: ['camelCase'],
      },
      {
        selector: 'variable',
        format: ['camelCase', 'PascalCase', 'UPPER_CASE'],
      },
    {
        selector: 'variable',
        types: ['array'],
        format: ['camelCase', 'PascalCase', 'UPPER_CASE'],
        suffix:['s', 'arr', 'Arr', 'Group', 'group'],
      },
      {
        selector: 'variable',
        types: ['boolean'],
        format: ['PascalCase'],
        prefix: ['is', 'should', 'has', 'can', 'did', 'will', 'does', 'are', 'do'],
      },
      {
        selector: 'parameter',
        format: ['camelCase'],
        leadingUnderscore: 'allow',
      },
      {
        selector: 'memberLike',
        modifiers: ['private'],
        format: ['camelCase'],
        leadingUnderscore: 'require',
      },
      {
        selector: 'typeLike',
        format: ['PascalCase'],
      },
      {
        selector: 'interface',
        format: ['PascalCase'],
        prefix: ['I'],
      },
      {
        selector: 'typeParameter',
        format: ['PascalCase'],
        suffix: ['Type'],
      },
    ],
}
```

### EditMode(수정모드) context 생성

- 수정모드일 때와 아닐 때의 상태도 여러 컴포넌트에 영향을 준다는 걸 놓쳤다.
- 컴포넌트 구조 도표에도 이 부분을 반영했다.

![스크린샷, 2021-08-13 22-51-48](https://user-images.githubusercontent.com/47022167/129367496-e73b8a94-3da4-4808-b279-e79908486c6b.png)

- context를 커스텀해도 콜백 헬과 유사한 패턴이 보이려고 한다. 일단 이 이상으로는 더 안 쓸 것 같아서 괜찮을 것 같다. 만약 더 많아진다면 Provider까지 한 번에 묶는 상위 컴포넌트를 생성하는 게 좋을까? 궁금하다.

```ts
const KeyboardAccessoryViewWrapper: React.FC<IKeyboardAccessoryViewWrapperProps> = ({
  renderScrollable,
}) => {
  return (
    <FolderNameProvider>
      <ColorProvider>
        <EditModeProvider>
          <KeyboardAccessoryView renderScrollable={renderScrollable}>
            <KeywordAccessoryGroup />
            <ColorAccessoryGroup />
          </KeyboardAccessoryView>
        </EditModeProvider>
      </ColorProvider>
    </FolderNameProvider>
  )
}
```
