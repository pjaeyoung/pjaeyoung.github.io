---
title: '20'
date: 2021-03-09 20:03:52
category: challenge30
thumbnail: { thumbnailSrc }
draft: false
---

<h1 style="border-bottom:0">TDD로 구현한 Infinite Scroll</h1>
<p>이제껏 책에 적혀있는 대로 TDD를 따라해봤다가 혼자서 연습해볼 생각에 Infinite Scroll 이라는 작은 기능을 구현을 목표로 TDD를 적용해보기로 했다. TDD 리듬을 전혀 몰랐던 이전과 달리 어떤 식으로 describe와 it 문구를 작성할 때 큰 어려움이 없었다. 다만 어떤 기능을 각 클래스마다 담당할지 , 그 관계는 어떠한지 등등을 고려하지 않고 무작정 테스트 코드를 작성하다보니 테스트 코드와 실제 코드 구현 과정에서 걸린 시간이 배로 늘었다.</p>


<p>우선 Infinite Scroll 이 어떤 기능을 할 지 정의를 내렸다.</p> 

> ### 기능 정의
> - 여러 개의 아이템들을 담은 목록이 존재한다. 
> - 아이템의 형태는 확장성과 재사용성을 위해 특정 짓지 않는다. 
> - 한 번에 로드할 아이템 개수를 지정한다.
> - 처음에 목록의 일부만 렌더링한다. 
> - 스크롤이 끝나면 지정한 개수만큼 추가적으로 렌더링한다. 

<br/>
<p>그 다음 재사용성/확장성은 무시하고 실제로 동작하는 수준의 코드를 작성한다. 그리고 리팩토링 과정에서 코드를 참고하며 TDD를 진행한다. 
</p>

<p>사실 이런 방식은 엄밀한 TDD에서 어긋난다. 아직 TDD를 한 경험이 부족하거나 전체 구조를 짜 본 경험이 미숙해서 곧바로 어떤 클래스에 어떤 메서드들이 필요하다고 판단하기 어려운 경우 이 방식을 추천한다. </p>

<p>일단 웹에서 구동되는 수준으로 짜본 코드는 다음과 같다.</p>

```js
function callback(entries, observer) {
  const isIntersecting = entries[0].isIntersecting;
  const currentItem = entries[0].target;
  const startIndex = parseInt(currentItem.dataset.index);

  if (isIntersecting) {
    observer.unobserve(currentItem);
    const items = data
      .slice(startIndex + 1, startIndex + 1 + PER_ITEMS)
      .map((item, index) => {
        const $li = document.createElement("li");
        $li.className = "scroll-item";
        $li.textContent = item;
        $li.dataset.index = startIndex + 1 + index;
        $scrollList.appendChild($li);
        return $li;
      });

    const lastIndex = parseInt(items[items.length - 1].dataset.index);
    if (lastIndex + 1 === MAX_ITEMS) {
      observer.disconnect();
    } else {
      observer.observe(items[items.length - 1]);
    }
  }
}

const data = new Array(21).fill().map((_, i) => `item ${i + 1}`);

const $scrollList = document.querySelector("#scroll-list");

const MAX_ITEMS = data.length;
const PER_ITEMS = 5;

const items = data.slice(0, PER_ITEMS).map((item, index) => {
  const $li = document.createElement("li");
  $li.className = "scroll-item";
  $li.textContent = item;
  $li.dataset.index = index;
  $scrollList.appendChild($li);
  return $li;
});

const options = {
  thresold: 0.5,
};

const io = new IntersectionObserver(callback, options);

io.observe(items[items.length - 1]);

```

<p> IntersectionObserver가 감지할 때 호출하는 callback 함수와 처음 웹을 방문하자마자 실행하는 부분에서 중복되는 코드(아이템목록 중 일부만 엘리먼트로 생성)가 보인다.
<p> 그리고 callback 함수에서 처리하는 로직이 다소 복잡하다. callback에서 target이 화면에 노출되었는지 확인하는 작업, 노출된 target 감시를 중지하는 작업, 논출된 target이 가진 dataset에서 마지막으로 출력된 index값을 얻어내는 과정 , 그 index값을 기준으로 일정 개수만큼 목록에서 잘라 엘리먼트를 생성하는 과정, 아직 렌더링할 부분이 남았다면 생성된 엘리먼트의 마지막 엘리먼트를 감시하고 모두 렌더링되었다면 감시를 종료하는 판단과정들이 있다. 
</p> 
<p>
단일책임원칙을 적용해서 목록들을 보관하고 렌더링을 담당하는 클래스와 렌더링된 엘리먼트들을 감시하는 클래스를 나누어서 처리할 필요가 있다. 
</p>
<p> 옆길로 새자면, 구현 과정에서 에러사항이 있었다. 몰랐는데 callback함수가 스크롤하지 않아도 계속 호출된다. <code style="background-color:#ECE5F1;padding: 1px 5px;color:purple;">entries[0].isIntersectioning</code> 을 작성하지 않았더니 콘솔창이 터지려고 하길래 무슨 일인가 했다. 마지막으로 생성된 엘리먼트가 화면에 보이기 시작했을 때 새로 그리기 위한 준비를 하면 되기 때문에 마지막 엘리먼트만 감시하려고 했다. 생성된 엘리먼트의 dataset에 index값을 보관했다가 이 index를 기준으로 다시 일정 개수를 자른다. dataset에 들고 오는 값은 string이라 parseInt를 사용해서 숫자로 변환해야 해서 번거롭다. 이 부분을 까먹어 string 과 +연산자는 문자열로 바뀌는 자바스크립트 특이한 현상으로 인해 에러를 찾느라 혼이 났다. </p>

<p>클래스는 ScrollList와 InfiniteScroll 두 종류로 구분했다. 그런데 작성하다보니 InfiniteScroll을 굳이 클래스로 구현할 필요가 있었나 싶다. 그저 IntesectionObserver를 생성하는 기능 밖에 없기 때문이다. 게다가 클래스 내부에서 private하게 IntersectionObserver 인스턴스를 생성하는 바람에 테스트하기가 어려웠다. 그래서 다시 리팩토링한다면 callback함수를 생성하는 함수를 작성하여 테스트하는 쪽으로 가면 훨씬 용이할 것이다.</p>

```js
import ScrollList from "./components/ScrollList.js";

export default class InfiniteScroll {
  constructor({ scrollList, options }) {
    if (
      !(scrollList instanceof ScrollList) ||
      (options && typeof options !== "object")
    ) {
      throw new Error(InfiniteScroll.messages.invalidConstructorArg);
    }

    this.scrollList = scrollList;
    // IntersectionObserver를 private하게 내부에서 생성하고 있다. 
    this.io = new IntersectionObserver(this._callback.bind(this), options);
    // 생성하자마자 IntersectionObserver 인스턴스가 scrollList에서 건네받은 마지막 렌더링된 아이템을 감시했는지 테스트하기 어렵다.
    this.io.observe(this.scrollList.getLastRenderedItem());
  }
  // 여담이지만 callback을 처음 작성한 코드보다 간결하고 읽기 쉬우며 책임이 명확하게 리팩토링이 되었다고 자부한다.  
  _callback(entries, observer) {
    if (!entries[0].isIntersecting) return;
    observer.unobserve(entries[0].target);
    if (this.scrollList.isAllItemsRendered()) { // 모든 아이템이 렌더링되었는지는 scrollList가 검증한다.
      observer.disconnect();
    } else {
      this.scrollList.render(); // 일정 개수만큼 추가적인 렌더링은 scrollList가 담당한다. 
      observer.observe(this.scrollList.getLastRenderedItem()); // 마지막으로 그려진 아이템은 scrollList가 알고 있기 때문에 여기서 신경쓸 필요 없다. 
    }
  }
}

InfiniteScroll.messages = {
  invalidConstructorArg: "잘못된 인자로 인스턴스를 생성했습니다.",
};

```
<p>테스트할 때 제일 귀찮은 작업 중 하나는 인자를 검증하는 과정이었다. 한 두개가 아니라 여러 개 인자를 받으면 검증해야할 케이스가 많아졌다. typescript를 쓰면 이 부분을 덜어낼 수 있을텐데 하며 한숨이 나왔다. 그래도 기본 vanilla javascript를 제대로 사용할 땐 필요한 작업이니 귀찮더라도 꼭 해야겠다.</p>

```js
 describe("constructor({$target, items, renderPerItem, createElement})", () => {
    const goodArg = {
      $target: document.createElement("ul"),
      items: [],
      renderPerItem: 5,
      createElement: function () {},
    };

    it("잘못된 인자로 인스턴스를 생성하면 에러를 던집니다.", () => {

    // 4개 인자만 해도 이렇게 어마어마한 케이스가 나온다. 사실 다 커버했다고 장담하진 못하겠다.
    // 조금이라도 수고를 덜기 위해 올바른 예시를 변수로 지정하여 가져다 썼다. 
      const badArgs = [
        { ...goodArg, $target: null },
        { ...goodArg, $target: undefined },
        { ...goodArg, $target: 1 },
        { ...goodArg, $target: true },
        { ...goodArg, $target: function () {} },
        { ...goodArg, $target: {} },
        { ...goodArg, $target: [] },
        { ...goodArg, items: null },
        { ...goodArg, items: undefined },
        { ...goodArg, items: 1 },
        { ...goodArg, items: true },
        { ...goodArg, items: function () {} },
        { ...goodArg, items: {} },
        { ...goodArg, renderPerItem: null },
        { ...goodArg, renderPerItem: undefined },
        { ...goodArg, renderPerItem: true },
        { ...goodArg, renderPerItem: function () {} },
        { ...goodArg, renderPerItem: {} },
        { ...goodArg, renderPerItem: [] },
        { ...goodArg, createElement: null },
        { ...goodArg, createElement: undefined },
        { ...goodArg, createElement: 1 },
        { ...goodArg, createElement: true },
        { ...goodArg, createElement: {} },
        { ...goodArg, createElement: [] },
      ];

      badArgs.forEach((arg) => {
        expect(function shouldThrow() {
          new ScrollList(arg);
        }).toThrowError(ScrollList.messages.invalidConstructorArgs);
      });
    });
 });
```
