---
title: '17'
date: 2021-03-03 21:03:92
category: challenge30
thumbnail: { thumbnailSrc }
draft: false
---

## FE 과제 도중 만난 헷갈리는 개념 

### 1. Async / Await
- 함수 정의 시 맨 앞에 `async`를 쓰면 `return` 값은 `Promise` 객체다. 직접 `Promise` 객체를 반환하지 않고 일반적인 값 (가령 숫자 10)을 반환하면 이행된 `Promise` 객체로 반환된다. 
```js
async function returnPromise10(){
    return 10;
}

console.log(returnPromise10()); // Promise{<fullfilled> : 10}

```
- `await`은 반드시 `async`와 함께 사용해야 하며 `Promise`가 이행 되기 전까지 코드 진행을 멈춘다. `await`이 속한 함수 내에서 코드가 실행되지 않는다는 말일 뿐 해당 함수 밖의 코드는 계속 실행된다(논블로킹);
- 스택을 여러 개 쌓아올렸을 때(함수 안에 여러 번 함수를 호출한 경우) 맨 위의 호출된 함수에서 `await`을 사용했다고 해서 중간에 `await`을 빼먹어도 되는 것은 아니다. 앞서 말했든 `await`의 제어 범위는 `await`이 속한 함수 안으로 제한되기 때문이다! 

```js
async function asyncFunc3() {
    return new Promise((resolve)=>{
        setTimeout(()=>resolve("asyncFunc3"), 2000);
    }
    )
}

async function asyncFunc2() {
    const res = await asyncFunc3(); 
    return res + " asyncFunc2";

}

async function asyncFunc1() {
    const res = asyncFunc2(); // 내부 함수 asyncFunc2에서 await을 썼다고 39번째 줄에서 멈추지 않는다. 
    console.log(res + " asyncFunc1");
}

asyncFunc1(); // [object Promise] asyncFunc1

```

### 2. Error Handling
[미디엄 - Handling Errors in JavaScript: The Definitive Guide](https://levelup.gitconnected.com/the-definite-guide-to-handling-errors-gracefully-in-javascript-58424d9c60e6) 글을 읽고 요약

- error를 state로 보관하기 
- 에러 케이스별 프론트 엔드 대응
    - 1. 글로벌 에러 - 백엔드 : 독립적인 alert ui로 표시됨, 
    - 2. 로컬 에러 - 백엔드 : 다른 ui와 같이 사용(가령, input창 아래에 빨간 경고글), 백엔드에서 확인해야만 하는 에러 케이스(가령, 로그인 시 이메일 정보 오류)
    - 3. 로컬 에러 - 프론트엔드 : 다른 ui와 같이 사용(가령, input창 아래에 빨간 경고글), 프론트엔드에서 자체 검증가능한 에러(가령, 로그인 시 이메일 양식 오류)
- `try catch`문에서 `console.error`는 옛날 방식이다. 디버깅을 위한다면 production에서는 콘솔창에 보이지 않는 [loglevel](https://www.npmjs.com/package/loglevel) 을 사용할 것!
