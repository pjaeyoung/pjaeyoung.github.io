<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[DODO's DEV LOG]]></title><description><![CDATA[daily life, development, reading, etc.]]></description><link>https://pjaeyoung.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sat, 13 Feb 2021 07:22:04 GMT</lastBuildDate><item><title><![CDATA[07]]></title><description><![CDATA[<자바스크립트 코딩의 기술> 요약 정리 08장 클래스로 인터페이스를 간결하게 유지하라  es…]]></description><link>https://pjaeyoung.github.io/Dev/07/</link><guid isPermaLink="false">https://pjaeyoung.github.io/Dev/07/</guid><pubDate>Thu, 11 Feb 2021 17:02:56 GMT</pubDate><content:encoded>&lt;h3 id=&quot;자바스크립트-코딩의-기술-요약-정리&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%BD%94%EB%94%A9%EC%9D%98-%EA%B8%B0%EC%88%A0-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC&quot; aria-label=&quot;자바스크립트 코딩의 기술 요약 정리 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&amp;#x3C;자바스크립트 코딩의 기술&gt; 요약 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;08장 클래스로 인터페이스를 간결하게 유지하라 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;es6부터 지원되는 클래스는 전혀 새로운 문법이 아니라 기존의 프로토타입으로 속성과 메서드를 상속하는 방식을 다른 객체 지향 언어의 클래스 형식을 차용한 문법이다. 다만 자바스크립트의 독특한 this의 성질은 남아있기 때문에 주의해야 한다. &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클래스의 constructor 함수는 생성자 함수 역할을 한다. constructor 함수 안에서 속성을 추가한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현재까지 자바스크립트는 공식적으로 private 속성을 지원하지 않는다. 어디서든 속성값에 곧바로 접근해서 값을 수정할 수 있다는 취약점은 원래 의도했던 데이터 형태를 훼손(가령, string이었던 속성값을 number로 변경)할 가능성으로 이어진다. &lt;/li&gt;
&lt;li&gt;private 속성 대신 컨벤션과 getter, setter 메서드로 취약점을 보완한다. 속성명 맨 앞은 언더바(_)를 적어 private한 속성임을 명시한다. 외부에서 사용할 때는 동일한 이름의 get, set 메서드 형식으로 표현한다. 클래스 내부는 메서드 형식이지만 외부에서는 마치 속성처럼 접근할 수 있다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클래스의 메서드 안에서 인자로 this에 접근하는 콜백함수를 받는 함수를 실행할 때 아무 조치가 없다면 this는 객체 인스턴스가 아닌 global, window 객체를 가리킨다. this는 오직 생성자 함수와 메서드 내에서(메서드 몸체 안에 곧바로)만 인스턴스에 접근할 수 있기 때문이다. 이 경우 bind를 사용하여 this를 인스턴스로 묶어주면 된다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;여러 메서드를 걸쳐 사용된다면 생성자 함수에서 bind로 단 한 번만 묶어준다. 혹은 화살표 함수를 사용한다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;제너레이터는 함수 실행을 중간에 멈추고 반환하는 함수다. 복잡한 객체 형태(중첩객체)를 순회할 때 유용하다. 클래스 메서드 형태는 &lt;code class=&quot;language-text&quot;&gt;*[Symbol.iterator](){}&lt;/code&gt; 이고 반복문을 사용해서 중첩 객체에 접근하는 로직을 작성한다. 외부에서는 &lt;code class=&quot;language-text&quot;&gt;for ... of&lt;/code&gt; 나 spread operator를 사용한 분해 할당이 가능하다.       &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[06]]></title><description><![CDATA[<자바스크립트 코딩의 기술> 요약 정리 0…]]></description><link>https://pjaeyoung.github.io/Dev/06/</link><guid isPermaLink="false">https://pjaeyoung.github.io/Dev/06/</guid><pubDate>Wed, 10 Feb 2021 14:02:16 GMT</pubDate><content:encoded>&lt;h3 id=&quot;자바스크립트-코딩의-기술-요약-정리&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%BD%94%EB%94%A9%EC%9D%98-%EA%B8%B0%EC%88%A0-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC&quot; aria-label=&quot;자바스크립트 코딩의 기술 요약 정리 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&amp;#x3C;자바스크립트 코딩의 기술&gt; 요약 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;07장 유연한 함수를 만들어라 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개인적으로 가장 습득하고 싶은 고급 기술들(내 기준에서)을 소개하고 있다. 의존성 주입/고차함수(부분적용함수, 커링)는 함수의 재사용성을 높이고 각 함수가 제어해야 할 변수들을 줄여준다. &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테스트하기 쉬운 함수란 순수함수 즉, 외부와 소통할 수 있는 유일한 창구인 인자를 가지고 결과물을 반환하는 함수다. 함수 안에서 또 다른 함수를 호출하는 경우가 종종 있는데 이 경우 내부 함수가 외부 api를 요청하거나 비동기적으로 작동할 때 테스트를 작성하기가 까다로워진다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sinon 라이브러리의 stub, mock, spy 와 같은 헬퍼 함수(jest의 경우 spyOn, fn, mock)를 사용하여 해결한다. &lt;/li&gt;
&lt;li&gt;이보다 더 간단한 방법은 내부에 뒀던 함수를 밖으로 꺼내어 그 결과물을 인자로 받도록 구현하는 것이다. 이를 &lt;strong&gt;의존성 주입&lt;/strong&gt; 이라 일컫는다.&lt;/li&gt;
&lt;li&gt;헬퍼 함수를 많이 쓴다는 것은 그만큼 코드가 복잡하고 의존성이 크다는 증거이다. 테스트를 작성하기 전에 코드를 리팩토링해야 할 시점인지 의심해봐야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;고차함수는 인자로 함수를 받거나 함수를 반환하는 함수를 일컫는다. 고차함수의 특징을 이용해서 인자들을 받을 시기를 늦출 수 있다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;부분 적용 함수와 커링은 원래 받아야 할 인자 개수 보다 적은 인자를 받는 함수를 반환하는 함수를 의미한다. 커링은 인자 개수를 하나로 고정하는 특징이 있다. &lt;/li&gt;
&lt;li&gt;만약 같은 인자를 반복적으로 넘겨서 작업하는 함수가 있다면 부분적용 함수나 커링으로 리팩토링해볼 가치가 있다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;자바스크립트에서 this는 문맥에 따라 값이 달라진다. 객체 메서드에서 객체 속성값을 this로 접근한 채 콜백 함수로 넘길 경우 객체 인스턴스의 문맥을 상실하고 global객체(window객체)를 가리키게 되어 오작동을 하게 된다. 이때 콜백 함수를 화살표 함수로 사용하면 바로 상위의 스코프에서 가리키는 this 즉, 객체 인스턴스를 유지한다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[05]]></title><description><![CDATA[06 장 매개변수와 return…]]></description><link>https://pjaeyoung.github.io/Dev/05/</link><guid isPermaLink="false">https://pjaeyoung.github.io/Dev/05/</guid><pubDate>Tue, 09 Feb 2021 14:03:36 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;06 장 매개변수와 return 문을 정리하라 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발하면서 흔히 겪는 일 중의 하나가 기존에 만든 함수를 확장하는 일이다. 하나만 받던 인자를 두 개, 세 개씩 추가해야 할 때 해당 함수가 쓰인 모든 파일을 찾아서 값을 넘겨주는 일은 번거로우며 깜빡 잊고 건너뛰어버릴 수 있다. 차라리 수정하는 함수 안에서 예외처리를 하는 편이 낫다. undefined인 경우를 따져 삼항연산자나 단락평가를 해서 기본값을 지정해도 인자가 많아질 수록 코드가 장황해진다. 이때 매개변수 기본값을 사용하면 중괄호 안에서 undefined 인지 판단하는 과정과 기본값 설정하는 과정을 압축할 수 있다. &lt;/li&gt;
&lt;li&gt;매개변수 기본값 설정의 단점은 인자를 순서대로 넘겨야 하기 때문에 중간을 비워둘 수 없다는 점이다. undefined를 직접 넘겨줘도 되지만 인자 개수가 많아지면 순서가 헷갈려 실수할 가능성이 높다. &lt;/li&gt;
&lt;li&gt;객체의 해체할당을 통해서 필요한 인자만 넘겨줄 수 있다. 해체 할당은 마치 변수를 새롭게 선언하듯 사용하며 중괄호({})로 감싸 객체의 속성임을 표시한다. 변수명은 반드시 객체에 지정한 속성명과 일치해야 한다. 만약 속성명과 일치하지 않으면 undefined 값이 나온다. &lt;/li&gt;
&lt;li&gt;해체 할당과 더불어 spread operator를 같이 사용하면 일부 속성만 변경한 새로운 객체를 생성할 때 편리하다. 값이나 명칭을 변경할 속성만 해체 할당하고 나머지는 spread operator로 가져와 반환 할 중괄호({})에 원하는 형태로 재할당을 한다. &lt;/li&gt;
&lt;li&gt;배열의 해체 할당은 대괄호([]) 안에서 맨 앞의 항목 부터 변수 처럼 선언하여 가져올 수 있다. spread operator를 사용하면 일부 항목은 변수처럼 가져와 사용하고 나머지는 배열 형태를 유지하여 사용할 수 있다. &lt;/li&gt;
&lt;li&gt;rest parameter는 정확히 개수를 알 수 없는 여러 자료형들의 인자들을 배열 형태로 묶어서 가져올 때 사용한다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[04]]></title><description><![CDATA[05장 반복문을 단순하게 만들어라  for…]]></description><link>https://pjaeyoung.github.io/Dev/04/</link><guid isPermaLink="false">https://pjaeyoung.github.io/Dev/04/</guid><pubDate>Mon, 08 Feb 2021 14:03:30 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;05장 반복문을 단순하게 만들어라 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;for문 대신 배열 메서드를 사용하는 편이 좋다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변수를 새롭게 할당하는 과정을 생략할 수 있다. &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;관심사를 하나로 줄일 수 있다. 한 가지 기능을 수행하기 때문에 자세히 코드를 들여다보지 않아도 메서드만 보고 반환 형태가 어떠할 지 예측 가능하다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;map() : 같은 길이, 변경된 형태로 반환. 주로 객체의 일부 속성으로 이뤄진 배열을 생성할 때 사용한다. &lt;br/&gt;
filter() : 형태 유지, 변경된 길이를 반환. 주로 특정 조건에 해당하는 배열 항목들로 이뤄진 새로운 배열을 생성할 때 사용한다. &lt;br/&gt;
find() : 단 하나만 있을 거라 예상되는 항목이거나 하나만 필요할 때 사용한다. 조건에 맞는 항목이 없을 경우 undefined를 반환한다. 이 경우 단락 평가(|| 연산자)로 const 변수 할당을 유지할 수 있다.&lt;br/&gt;
forEach() : 형태나 길이 변형 없이 배열 항목에 같은 동작을 실행할 때 사용한다.다른 배열 메서드와 달리 외부 조작으로 이어지나 체이닝을 적용하여 이전에 처리한 결과값을 따로 변수를 할당하여 저장할 필요를 줄여준다. &lt;br/&gt;
reduce() : 길이와 형태 모두 변경할 수 있다. 다른 배열 메서드와 달리 콜백함수에 두 번째 인자(배열 항목)를 필수 인자로 받는다. reduce 메서드의 두 번째 인자에서 누적값의 초기 형태를 지정할 수 있다. 반환값 형태를 예측가능하게 해주기 때문에 되도록 초기 형태를 지정할 것을 권장한다.   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;때때로 컬렉션을 배열로 변환하는 과정이 번거로울 수 있다. 이 경우 &lt;code class=&quot;language-text&quot;&gt;for ... of&lt;/code&gt; 문을 사용하면 형변환 없이 각각의 값들을 순회할 수 있다. &lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;for ... in&lt;/code&gt; 문은 객체의 모든 열거 가능한 키 값들을 순회할 수 있게 해준다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[03]]></title><description><![CDATA[04장 조건문을 깔끔하게 작성하라 조건식을 작성할 때 자바스크립트의 문법 상  를 falsy한 값으로 여기기 때문에 발생하는 버그를 줄이기 위해서 bool형(true/false…]]></description><link>https://pjaeyoung.github.io/Dev/03/</link><guid isPermaLink="false">https://pjaeyoung.github.io/Dev/03/</guid><pubDate>Sat, 06 Feb 2021 00:03:34 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;04장 조건문을 깔끔하게 작성하라&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;조건식을 작성할 때 자바스크립트의 문법 상 &lt;code class=&quot;language-text&quot;&gt;&amp;#39;&amp;#39;,null, undefined,0,false&lt;/code&gt; 를 falsy한 값으로 여기기 때문에 발생하는 버그를 줄이기 위해서 bool형(true/false) 체크로 엄격하게 작성할 것을 권장한다.&lt;/li&gt;
&lt;li&gt;짧은 조건식일 경우 삼항 연산자를 사용하면 더 좋다. 특정 변수가 조건에 따라 값이 다르게 할당되어야 할 경우(가령, 나이가 19세 이상일 때 입장여부에 대한 변수) 삼항 연산자를 사용하지 않고 조건문(if)을 작성하면 외부에 let 키워드로 변수를 선언하고 조건문 안에서 할당하는 과정을 거치게 된다. 하지만 삼항연산자는 같은 라인에 조건식에 따라 값을 결정하므로 const 키워드를 사용할 수 있고 예측 가능하고 코드 라인 수를 줄여 작성할 수 있다. &lt;/li&gt;
&lt;li&gt;|| 연산자는 삼항 연산자와 마찬가지로 한줄로 const 키워드 선언 및 할당을 가능하게 만든다. || 연산자 앞의 값이 falsy하다면 || 연산자 뒤의 기본값을 할당하도록 할 수 있다. &lt;/li&gt;
&lt;li&gt;&amp;#x26;&amp;#x26; 연산자는 &amp;#x26;&amp;#x26; 연산자 앞의 조건식이 충족되어야 &amp;#x26;&amp;#x26; 연산자 뒤의 값을 반환하거나 조건식을 진행한다. if문 중첩없이 객체의 속성값이 존재할 때만 속성값에 또 다른 처리를 할 경우 유용하다.       &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[02]]></title><description><![CDATA[하루에 2 장을 읽고 정리하려고 마음을 먹었는데 항상 1장을 겨우 끝낸다. 꾸준히 공부한다는 데 의미를 두고 너무 낙담하지 말자.…]]></description><link>https://pjaeyoung.github.io/Dev/02/</link><guid isPermaLink="false">https://pjaeyoung.github.io/Dev/02/</guid><pubDate>Thu, 04 Feb 2021 23:03:16 GMT</pubDate><content:encoded>&lt;p&gt;하루에 2 장을 읽고 정리하려고 마음을 먹었는데 항상 1장을 겨우 끝낸다. 꾸준히 공부한다는 데 의미를 두고 너무 낙담하지 말자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;3장 특수한 컬렉션을 이용해 코드 명료성을 극대화하라 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;배열 다음으로 많이 쓰는 객체를 소개했다. 객체를 정적인 키-값 컬렉션으로 바라본 점이 신선했다. 각종 config 파일을 객체 형태로 export하는 예를 들어서 이해가 갔다. 정적인 객체를 프로그래밍적으로 접근하는 방법은 정해진 틀, 구조(키)에 값만 갈아끼우는 식으로 새로 생성하는 함수를 이용하는 것이다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이전 장들에서도 계속 강조했듯 객체에서도 조작을 가하지 않는 방향으로 코드를 작성하길 권한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Object.assign&lt;/code&gt;을 이용하는 방법과 spread operator(…)을 사용하는 방법이 있는데 후자가 훨씬 직관적이고 첫 번째 인자에 빈 객체({})를 할당해야 한다는 주의사항을 기억하지 않아도 된다는 점에서 좋다. 사람의 기억력의 한계, 모든 문법을 기억하기 어려운 점이 오용으로 인한 에러를 낳을 가능성이 크다는 점을 계속해서 강조한다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;만약 키가 유동적으로 변한다면 객체보다는 map 사용을 권장한다. 객체의 경우 키 추가/삭제/전체 삭제 기능을 구현할 때 통일되지 않은 방식(객체 내장 메서드, delete 연산자,빈 객체 재할당)을 취한다. map의 경우 인스턴스의 내장 메서드로 접근(add,delete,clear)한다. 그리고 그 인터페이스(메서드)의 명칭이 기능을 분명히 드러낸다.&lt;/li&gt;
&lt;li&gt;객체는 키와 값을 순회할 때 항상 &lt;code class=&quot;language-text&quot;&gt;Object.keys&lt;/code&gt; 로 키들로 이뤄진 배열로 변환 후 키들의 개수 만큼 순회하여 값을 접근해야 한다. 최근에는 &lt;code class=&quot;language-text&quot;&gt;for ... in&lt;/code&gt; 문법의 도입으로 변환과정의 필요성이 사라졌지만 키 만 접근할 수 있다는 한계가 있다. map은 &lt;code class=&quot;language-text&quot;&gt;for ... of&lt;/code&gt; 에서 키 값 을 튜플형식으로 곧바로 접근할 수 있다. 또한 대괄호([])안에서 spread operator(…)와 함께 사용하면 키 값 튜플형식으로 분리하여 가져올 수 있다. map이 배열 형태로 쉽게 변환할 수 있다는 점은 때때로 키-값 컬렉션을 배열 내장 메서드를 활용해야 할 때 장점이 된다.&lt;/li&gt;
&lt;li&gt;map의 조작/변형을 일으키는 내장 메서드(add, delete,clear)는 원본 손상의 위험(부수효과)이 있기 때문에 항상 spread operator(…)로 map 생성자에 넘겨 복사된 새 map을 만들어 사용한다. &lt;/li&gt;
&lt;li&gt;set은 고유한 값들로 구성된 특수한 배열이다. 하지만 배열과 달리 인덱스 접근은 불가능하다. map과 마찬가지로(add, delete,clear,has)와 같은 내장 메서드를 가지고 있다. 중복된 값들로 구성된 배열을 set의 생성자에 넘겨주면 고유한 값들로 구성된 컬렉션을 반환한다. 이를 다시 대괄호([])안에서 spread operator(…)와 함께 사용하면 중복이 없는 값들로 구성된 배열을 생성할 수 있다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[01]]></title><description><![CDATA[자바스크립트를 제대로 사용해보고 싶어서 조 모건이 쓴 <자바스크립트 코딩의 기술>을 읽고 있다. 
일주일 간 책 내용 복습 위주로 작성하지 않을까싶다.…]]></description><link>https://pjaeyoung.github.io/Dev/01/</link><guid isPermaLink="false">https://pjaeyoung.github.io/Dev/01/</guid><pubDate>Wed, 03 Feb 2021 22:02:47 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트를 제대로 사용해보고 싶어서 조 모건이 쓴 &lt;u&gt;&amp;#x3C;자바스크립트 코딩의 기술&gt;&lt;/u&gt;을 읽고 있다.
일주일 간 책 내용 복습 위주로 작성하지 않을까싶다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1장 변수 할당으로 의도를 표현하라 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코드 작성 시 변수 할당이 무수히 많이 일어난다. 내가 오늘 작성한 코드에서 몇 번이나 변수를 할당했는지 기억을 많이 할 수 없을 정도다. 가볍게 스치듯 작성하지만 &lt;strong&gt;가장 많이 작성&lt;/strong&gt;하기에 맨 처음 중요하게 다룬다.&lt;/li&gt;
&lt;li&gt;var는 어휘적 범위(lexical scope), let과 const는 블록 범위(block scope)이다. 블록 범위는 주로 중괄호({}) 안에서 유효한 값으로 취급한다는 의미다. 대표적으로 if문, for문이 있다. &lt;/li&gt;
&lt;li&gt;const를 우선으로 쓰고 필요할 때 let을 쓰는 전략을 추천한다. var는 블록 범위가 없다는 점, 재선언이 가능하고 호이스팅(선언부보다 앞서 접근/사용이 가능) 때문에 수 백줄의 긴 코드에서 값의 변화를 예측하기 어렵게 만든다. &lt;/li&gt;
&lt;li&gt;const는 처음 선언할 때 할당한 값을 유지하기 때문에 코드가 길어져도 그 값을 신경쓰지 않아도 된다(배열의 항목과 객체의 속성값은 예외다). const를 많이 쓰면 그만큼 변화가 일어나는 구간이 좁혀지고 신경써야할 변수의 개수가 줄어들어 결과적으로 버그를 발생할 확률을 줄여준다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2장 배열로 데이터 컬렉션을 관리하라&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최신 자바스크립트에서 다양한 데이터 컬렉션이 추가되었다. 그 중에서도 배열이 가장 많이 쓰이는 컬렉션이다. 값을 추가하고 제거하고 필터링하고 수정하는 기본적인 기능을 자체 배열 메소드에서 제공해준다. &lt;/li&gt;
&lt;li&gt;1장에서 const로 변화를 최소화하는데 배열이 예외가 된다고 말했다. 이 배열을 되도록 처음 상태를 유지하면서 프로그래밍하기 위해서는 &lt;strong&gt;사본&lt;/strong&gt;을 만들어 변형을 일으키는 것이다. 여기서 유용한 최신 문법은 전개연산자(spread operator)다. &lt;/li&gt;
&lt;li&gt;전개연산자는 각 배열의 항목들을 분리하여 가져오는 기능이다. 대괄호([])안에서 특정 배열을 전개연산자와 함께 쓰면 특정 배열의 항목들의 사본들로 구성된 새로운 배열을 반환한다. 전개연산자 개념만 알면 조작(추가/삭제/수정)을 위한 여러 배열 메소드를 기억할 필요 없다(과장하면 전개연산자가 만능키 역할을 한다).변경된 위치가 시각적으로 잘 보여주기 때문에 배열 메소드를 사용한 것보다 직관적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[첫 블로그]]></title><description><![CDATA[개인 블로그 만든 계기 작년에 부트캠프를 다니면서 매주 하나씩 velog에 TWIL을 올렸다.
처음엔 짜집거나 베끼기 정도로 그쳤지만 갈수록 내 말로 풀어서 작성하게 되었다. 글 한 편을 쓰는 데…]]></description><link>https://pjaeyoung.github.io/Daily/첫-블로그-/</link><guid isPermaLink="false">https://pjaeyoung.github.io/Daily/첫-블로그-/</guid><pubDate>Tue, 02 Feb 2021 13:02:39 GMT</pubDate><content:encoded>&lt;h3 id=&quot;개인-블로그-만든-계기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B0%9C%EC%9D%B8-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A0-%EA%B3%84%EA%B8%B0&quot; aria-label=&quot;개인 블로그 만든 계기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;개인 블로그 만든 계기&lt;/h3&gt;
&lt;p&gt;작년에 부트캠프를 다니면서 매주 하나씩 velog에 TWIL을 올렸다.
처음엔 짜집거나 베끼기 정도로 그쳤지만 갈수록 내 말로 풀어서 작성하게 되었다. 글 한 편을 쓰는 데 5시간 이상이나 걸렸지만 개념을 단단하게 잡고 간다는 게 느껴졌고 부트캠프가 끝날 때까지 지속적으로 블로깅을 할 수 있었다.&lt;/p&gt;
&lt;p&gt;하지만, 취업 후 바쁘다는 핑계로 블로그를 안 하게 되었다. 당장 눈 앞에 놓인 문제를 해결하느라 여기저기 흩어진 정보를 꾸역꾸역 머릿속에 넣기만 했다. 천천히 음미하여 먹지 못한 지식들은 제대로 소화되지 못한 채 장에 쌓여 탈이 나버렸다.&lt;/p&gt;
&lt;p&gt;나는 누구보다 콧대가 높아야 한다 생각했다. 기본기도 제대로 다지지 않은 상태에서 더 세련된 코드, 멋진 코드를 짜고 싶다는 생각에 사로잡혔다. 여기저기서 주어들은 팁들을 긴 고민 없이 가져다 쓰니 코드가 점점 엉망진창이었다. 퇴사 전 인수인계를 위해 문서화 작업을 하면서 &lt;strong&gt;다른 사람이 이해할 수 있는 코드&lt;/strong&gt; 를 작성하지 못하고 &lt;strong&gt;나만 아는 코드&lt;/strong&gt;를 작성했음을 깨달았다. &lt;strong&gt;기본에 충실하며 조금씩 다듬어가는 과정&lt;/strong&gt;에 익숙해지기 위해 다시 블로깅을 할 마음이 생겼다.&lt;/p&gt;
&lt;p&gt;개발자는 혼자서 개발하는 것이 아니다. 첫 입사 후 한달 정도는 이것저것 묻고 얘기하면서 작업을 했다. 점차 입을 닫고 등을 돌려 작업을 하다보니 프로젝트에 대해 서로 생각한 바가 달라 수정사항이 발생하고 개발 일정에 차질이 생겼다. 열심히 만들어 놓고 다시 수정하는 일이 반복되다보니 의욕이 사라졌다. 얼마 전 들었던 &lt;a href=&quot;https://event-us.kr/FKH3nHkjmPGh/event/28118?state=1&quot;&gt;데브그라운드(한빛미디어 주최 개발강연)&lt;/a&gt; 에서 &lt;strong&gt;회의시간 외에 일상적으로 지속적인 교류&lt;/strong&gt;가 필요하다는 말이 와닿았다.&lt;/p&gt;
&lt;p&gt;소통할 줄 아는 개발자가 되기 위한 첫 걸음은 생각을 정리하고 표현하는 글쓰기라 생각한다. 내가 어떤 사고과정에서 이런 결론에 도달했는지 글로 정리하면 자연스럽게 대화로도 이어진다.&lt;/p&gt;
&lt;p&gt;그래서, 앞으로 블로그를 아래와 같이 진행할 예정이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;블로깅-진행-방식&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B8%94%EB%A1%9C%EA%B9%85-%EC%A7%84%ED%96%89-%EB%B0%A9%EC%8B%9D&quot; aria-label=&quot;블로깅 진행 방식 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;블로깅 진행 방식&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;30일간 매일 작성한다. ( 30일 챌린지를 통해 글쓰기의 거부감을 없앤다.)&lt;/li&gt;
&lt;li&gt;블로깅에 쓸 내용은 복습,프로젝트 진행과정, 문제해결과정, 개발 서적 및 강의 정리로 구성된다. (일상 글이나 개발 외적인 글은 30일 챌린지에 포함하지 않는다.)&lt;/li&gt;
&lt;li&gt;블로깅할 때 가장 중요한 점은 &lt;strong&gt;보지않고 작성하기&lt;/strong&gt; 이다. 내 말로 풀어쓰는 방법 중에 최고다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;br/&gt;
&lt;br/&gt;
깜빡 잊고 소제목에 대한 설명을 언급하지 않았다. 
왜 있던 velog는 놔두고 개인 블로그를 사용하는가? velog도 딱히 찾아오는 이는 드물다. 보는 이가 적지만 언제든지 노출이 될 가능성이 있다는 점이 마음에 걸렸다. 아직은 내가 쓴 글이 남들에게 보여주기 민망하다고 느끼기 때문에 누가 억지로 내 블로그 링크를 누르지 않는 한 볼 수 없는 조금은 폐쇄적인 개인 블로그에서 글쓰기에 적응하고자 개인 블로그를 만들었다.
&lt;br/&gt;
&lt;br/&gt;
&lt;p&gt;개인 블로그는 한재엽님께서 만들어주신 &lt;a href=&quot;https://github.com/JaeYeopHan/gatsby-starter-bee&quot;&gt;gatsby-starter-bee&lt;/a&gt; 를 바탕으로 손쉽게 만들었다. ‘손쉽게라고 말했지만 처음에 많이 헤맸다. 깃헙페이지로 분명 올렸는데 계속 깃헙 README.md 만 보였다. 알고보니 gatsby-meta-config.js에서 siteUrl을 내 깃헙 url로 변경하지 않았기 때문이었다. 중간 중간 cache나 public 폴더를 삭제하지 않으면 gatsby-meta-config나 styles 수정 사항이 반영되지 않은 경우가 있으니 새로 글을 작성하면 이전 거는 지우고 deploy를 진행해야 했다. velog할 때보다 좀 불편한데(발행 시간 즉 deploy 시간이 길다) 이것도 금방 적응하겠지 하고 첫 블로그 글을 마무리한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[about]]></title><description><![CDATA[Your name Thank you for reading my resume. If you want to contact me, Please send me an email.]]></description><link>https://pjaeyoung.github.io/resume-en/</link><guid isPermaLink="false">https://pjaeyoung.github.io/resume-en/</guid><pubDate>Sun, 27 Jan 2019 16:21:13 GMT</pubDate><content:encoded>&lt;h1 id=&quot;your-name&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#your-name&quot; aria-label=&quot;your name permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Your name&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;em&gt;Thank you for reading my resume. If you want to contact me, Please send me an email.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>