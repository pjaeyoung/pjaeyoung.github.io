<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[DODO's DEV LOG]]></title><description><![CDATA[daily life, development, reading, etc.]]></description><link>https://pjaeyoung.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 07 Mar 2021 06:54:08 GMT</lastBuildDate><item><title><![CDATA[19]]></title><description><![CDATA[FE 테스트 토요일 오후 1시부터 4시까지 3시간 동안 프로그래머스에서 주최한 FE…]]></description><link>https://pjaeyoung.github.io/challenge30/19/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/19/</guid><pubDate>Sun, 07 Mar 2021 14:04:26 GMT</pubDate><content:encoded>&lt;h2 id=&quot;fe-테스트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#fe-%ED%85%8C%EC%8A%A4%ED%8A%B8&quot; aria-label=&quot;fe 테스트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;FE 테스트&lt;/h2&gt;
&lt;p&gt;토요일 오후 1시부터 4시까지 3시간 동안 프로그래머스에서 주최한 FE 과제 전형을 진행했다.
집중해서 작업해야 하는 시간 만큼 주말인데도 같이 사는 언니를 밖으로 떠밀고 최대한 조용한 환경을 갖추려 했다.
결론적으로 시간 안에 최소한의 기능도 구현하지 못했다. 완성률은 30%인 것 같다. 하지만 오랜만에 머리를 싸매고
코드를 짜니 기분이 좋았다. 미완성이긴 해도 과제에서 요구한 ‘재사용성을 고려한 코드’에 나름대로 근접한 것 같다.
변경사항이 생길 것으로 여기는 부분들을 모두 외부에서 인자로 전달받는 형태로 구현했다. 비슷한 형태의 UI 컴포넌트를 &lt;code class=&quot;language-text&quot;&gt;클래스 상속&lt;/code&gt;을 적용하였다. 또 외부 API를 요청할 때 응답을 받기 전 loading해야하는 부분을 api 객체가 대신 기억하여 매 호출마다 loading 컴포넌트를 실행하고 중지하도록 했다. &lt;/p&gt;
&lt;h2 id=&quot;infinite-scroll&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#infinite-scroll&quot; aria-label=&quot;infinite scroll permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Infinite Scroll&lt;/h2&gt;
&lt;p&gt;스크롤이 끝날 때마다 배열에 들어있는 데이터를 일정 갯수씩 추가적으로 로드하는 기능을 구현하고 있다.
lazy loading을 구현할 때 썼던 &lt;code class=&quot;language-text&quot;&gt;IntersectionObserver&lt;/code&gt;를 여기서도 사용한다.
테스트 코드를 짜면서 진행 중인데 바로 코드를 진행하지 않고 테스트부터 짜려니 시간이 오래 걸린다.
자동으로 어떤 기능들이 있어야 하고 어떤 순서로 실행할 건지 생각하게 만든다. 귀찮지만 이런 습관이 탄탄한 코드를 작성하는 기반이 될 것이다. &lt;/p&gt;
&lt;p&gt;테스트할 때 ‘window’ 환경이 아니라서 &lt;code class=&quot;language-text&quot;&gt;IntersectionObserver&lt;/code&gt;가 undefined 하다는 에러가 났다. 이 경우
&lt;code class=&quot;language-text&quot;&gt;beforeEach&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;window.IntersectionObserver = jest.fn(function(callback,options){})&lt;/code&gt; mock 함수를 생성하고 &lt;code class=&quot;language-text&quot;&gt;afterEach&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;window.IntersectionObserver.mockRestore()&lt;/code&gt; mock 함수를 지우면 된다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[18]]></title><description><![CDATA[TIL  lazy loading javascript로 lazy loading을 구현하는 방법을 알게 되었다. 
lazy loading은 모든 이미지를 화면에서 로드하는 대신 화면에서 보여질 부분만 로드하는 기법이다. 
코드 상으로 설명하자면 img…]]></description><link>https://pjaeyoung.github.io/challenge30/18/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/18/</guid><pubDate>Thu, 04 Mar 2021 10:03:50 GMT</pubDate><content:encoded>&lt;h2 id=&quot;til--lazy-loading&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#til--lazy-loading&quot; aria-label=&quot;til  lazy loading permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;[ TIL ] lazy loading&lt;/h2&gt;
&lt;p&gt;javascript로 lazy loading을 구현하는 방법을 알게 되었다.
lazy loading은 모든 이미지를 화면에서 로드하는 대신 화면에서 보여질 부분만 로드하는 기법이다.
코드 상으로 설명하자면 img 태그의 속성인 src에 곧바로 이미지 파일 경로를 입력하는 대신 디폴트 이미지를 입력하고 실제 이미지 파일 경로는 dataset에 저장한다. 팝업 혹은 스크롤로 인해 화면에 보이는 순간 디폴트 이미지를 dataset에 저장한 실제 이미지 파일로 대체한다. &lt;/p&gt;
&lt;p&gt;lazy loading을 구현하려면 &lt;code class=&quot;language-text&quot;&gt;IntersectionObserver&lt;/code&gt; 클래스를 사용한다.
&lt;code class=&quot;language-text&quot;&gt;IntersectionObserver&lt;/code&gt;는 특정 엘리먼트가 화면에 보여졌는지 감지하는 기능을 수행한다.
처음 new 연산자로 인스턴스를 생성할 때 생성자 인자로 ‘화면에 나타났을 때 실행할 동작을 정의한’ callback 함수와 ‘보여질 화면(엘리먼트) 설정과 얼마만큼 보여지면 콜백을 실행할지 결정할 비율(0.0~1.0)‘에 대한 옵션을 넘겨준다. callback은 반드시 넘겨줘야 할 필수 인자고 옵션은 말그대로 넘겨주지 않아도 디폴트 값으로 셋팅된다. &lt;/p&gt;
&lt;p&gt;lazy loading 구현 시 아래 사항을 고려한다.
- 어떤 화면(브라우저 스크린 혹은 화면에서 일부 구간)에서 보여줄지 결정한다. option의 root에 해당 정보를 입력한다.
- 어느 정도로 엘리먼트가 화면에서 노출되면 콜백함수를 실행할지 결정한다. option의 thresold에 해당 정보를 입력한다.
- 화면에 노출될 때 어떤 동작을 실행할지 결정한다. 여기서는 img의 src 값을 img의 dataset에 저장한 실제 경로값으로 대체하는 로직이 작성되어야 한다. 그리고 더이상 ‘감지’할 필요가 없으므로 감지해제 하는 과정도 여기서 이뤄진다. callback 함수에 해당 정보를 입력한다.
- 화면 노출 여부를 확인해야 할 대상(태그)들을 가져와 &lt;code class=&quot;language-text&quot;&gt;IntersectionObeserver&lt;/code&gt; 인스턴스에 감지 대상 목록에 등록한다.   &lt;/p&gt;
&lt;p&gt;lazy loading 구현과정에서 디폴트 이미지 파일이 없어 src를 비워둔 채로 로드했더니 ‘이미지가 깨졌을 때’ 나오는 아이콘이 생겨서 거슬렸다. 코드로 아이콘을 지우는 방법을 찾다가 &lt;code class=&quot;language-text&quot;&gt;data-url&lt;/code&gt; 방식으로 투명 이미지를 생성하는 방법을 알게 되었다. &lt;/p&gt;
&lt;h3 id=&quot;참고-자료&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C&quot; aria-label=&quot;참고 자료 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;참고 자료&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://yoonbumtae.com/?p=2847&amp;#x26;unapproved=573&amp;#x26;moderation-hash=58b869fac7c795a542c36fe5da4d2abb#comment-573&quot;&gt;lazy-loading&lt;/a&gt; &lt;/br&gt;
&lt;a href=&quot;https://blog.serpongs.net/59&quot;&gt;투명이미지&lt;/a&gt; &lt;/br&gt;
&lt;a href=&quot;https://mygumi.tistory.com/282&quot;&gt;data-url vs image file&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;daily&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#daily&quot; aria-label=&quot;daily permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;[ Daily ]&lt;/h2&gt;
&lt;p&gt;오늘 NomadCoders에서 주최한 투두리스트 대회 수상자 발표가 나왔다. 비록 제출은 못 했지만 나름 독특하게 했다고 생각했는데 수상작들을 보니 그 생각이 쏙 들어갔다. 짧은 시간 안에 여러 가지 기능들을 적용하고 css로 화려하게 꾸민 작품들을 보니 좌절감이 들 법한데 오기가 생긴다. 나도 저만큼 하고 말거다! 하는 마음 말이다. 책을 읽고 책 따라 코드 작성만 하고 있었는데 작은 프로젝트도 겸해서 해야겠다.&lt;/p&gt;
&lt;p&gt;요즘 늦잠을 많이 잔다. 앞으로 마치 직장을 다니는 것처럼 9시 - 6시로 공부 시간을 가진다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[17]]></title><description><![CDATA[FE 과제 도중 만난 헷갈리는 개념 1. Async / Await 함수 정의 시 맨 앞에 를 쓰면  값은  객체다. 직접  객체를 반환하지 않고 일반적인 값 (가령 숫자 10)을 반환하면 이행된  객체로 반환된다.  console.log…]]></description><link>https://pjaeyoung.github.io/challenge30/17/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/17/</guid><pubDate>Wed, 03 Mar 2021 21:04:32 GMT</pubDate><content:encoded>&lt;h2 id=&quot;fe-과제-도중-만난-헷갈리는-개념&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#fe-%EA%B3%BC%EC%A0%9C-%EB%8F%84%EC%A4%91-%EB%A7%8C%EB%82%9C-%ED%97%B7%EA%B0%88%EB%A6%AC%EB%8A%94-%EA%B0%9C%EB%85%90&quot; aria-label=&quot;fe 과제 도중 만난 헷갈리는 개념 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;FE 과제 도중 만난 헷갈리는 개념&lt;/h2&gt;
&lt;h3 id=&quot;1-async--await&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-async--await&quot; aria-label=&quot;1 async  await permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. Async / Await&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;함수 정의 시 맨 앞에 &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt;를 쓰면 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt; 값은 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt; 객체다. 직접 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt; 객체를 반환하지 않고 일반적인 값 (가령 숫자 10)을 반환하면 이행된 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt; 객체로 반환된다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;returnPromise10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;console.log(returnPromise10()); // Promise{&lt;fullfilled&gt; : 10}&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- `await`은 반드시 `async`와 함께 사용해야 하며 `Promise`가 이행 되기 전까지 코드 진행을 멈춘다. `await`이 속한 함수 내에서 코드가 실행되지 않는다는 말일 뿐 해당 함수 밖의 코드는 계속 실행된다(논블로킹);
- 스택을 여러 개 쌓아올렸을 때(함수 안에 여러 번 함수를 호출한 경우) 맨 위의 호출된 함수에서 `await`을 사용했다고 해서 중간에 `await`을 빼먹어도 되는 것은 아니다. 앞서 말했든 `await`의 제어 범위는 `await`이 속한 함수 안으로 제한되기 때문이다! 

```js
async function asyncFunc3() {
    return new Promise((resolve)=&amp;gt;{
        setTimeout(()=&amp;gt;resolve(&amp;quot;asyncFunc3&amp;quot;), 2000);
    }
    )
}

async function asyncFunc2() {
    const res = await asyncFunc3(); 
    return res + &amp;quot; asyncFunc2&amp;quot;;

}

async function asyncFunc1() {
    const res = asyncFunc2(); // 내부 함수 asyncFunc2에서 await을 썼다고 39번째 줄에서 멈추지 않는다. 
    console.log(res + &amp;quot; asyncFunc1&amp;quot;);
}

asyncFunc1(); // [object Promise] asyncFunc1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-error-handling&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-error-handling&quot; aria-label=&quot;2 error handling permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. Error Handling&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://levelup.gitconnected.com/the-definite-guide-to-handling-errors-gracefully-in-javascript-58424d9c60e6&quot;&gt;미디엄 - Handling Errors in JavaScript: The Definitive Guide&lt;/a&gt; 글을 읽고 요약&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;error를 state로 보관하기 &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;에러 케이스별 프론트 엔드 대응&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;글로벌 에러 - 백엔드 : 독립적인 alert ui로 표시됨, &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;로컬 에러 - 백엔드 : 다른 ui와 같이 사용(가령, input창 아래에 빨간 경고글), 백엔드에서 확인해야만 하는 에러 케이스(가령, 로그인 시 이메일 정보 오류)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;로컬 에러 - 프론트엔드 : 다른 ui와 같이 사용(가령, input창 아래에 빨간 경고글), 프론트엔드에서 자체 검증가능한 에러(가령, 로그인 시 이메일 양식 오류)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;try catch&lt;/code&gt;문에서 &lt;code class=&quot;language-text&quot;&gt;console.error&lt;/code&gt;는 옛날 방식이다. 디버깅을 위한다면 production에서는 콘솔창에 보이지 않는 &lt;a href=&quot;https://www.npmjs.com/package/loglevel&quot;&gt;loglevel&lt;/a&gt; 을 사용할 것!&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[16]]></title><description><![CDATA[프로그래머스 FE 과제 지원하기 프로그래머스에서 2021년 첫 Dev-Matching으로 FE 과제전형을 진행한다. 신청하고 난 후에야 여기저기서 FE…]]></description><link>https://pjaeyoung.github.io/challenge30/16/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/16/</guid><pubDate>Tue, 02 Mar 2021 22:03:36 GMT</pubDate><content:encoded>&lt;h2 id=&quot;프로그래머스-fe-과제-지원하기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-fe-%EA%B3%BC%EC%A0%9C-%EC%A7%80%EC%9B%90%ED%95%98%EA%B8%B0&quot; aria-label=&quot;프로그래머스 fe 과제 지원하기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;프로그래머스 FE 과제 지원하기&lt;/h2&gt;
&lt;p&gt;프로그래머스에서 2021년 첫 Dev-Matching으로 FE 과제전형을 진행한다. 신청하고 난 후에야 여기저기서 FE과제 진행 일자(이번주 토요일)에 좋은 주제로 강연이 두 개나 잡혀있는 걸 알고 양자택일의 고통을 받는다. 취업이 최우선이기 때문에 강연은 포기하기로 한다. 원래 한 번만 맛보기로 FE 과제 테스트를 하고 그 외 시간엔 못 다한 &amp;#x3C;자바스크립트 패턴과 테스트&gt; 책을 독파할 계획이었다. 오늘 FE 과제 테스트를 하고 난 뒤 안일한 생각이었음을 깨달았다. 작은 웹사이트를 오랜만에 코딩하려니 까먹은 게 많아 허둥지둥하고 폭풍검색에 시간을 허비하였다. 결국 절반도 못 푼 채 제출했다. 토요일 전까지 FE 과제 테스트를 꼼꼼히 작업하고 모르는 부분 정리하는 시간을 가질 생각이다.  &lt;/p&gt;
&lt;p&gt;FE 과제를 풀면서 놀란 건 작년에 자바스크립트 스터디에서 배웠던 vanilla javascript로 컴포넌트를 직접 구현하는 과정이 그대로 나와있다는 것이다. 각 컴포넌트(과제에선 클래스를 가리킴)에 제어할 DOM tag와 상태를 가지고 &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt;로 상태를 변경하면 &lt;code class=&quot;language-text&quot;&gt;render&lt;/code&gt;를 자동으로 호출하여 UI를 업데이트한다. 옛 기억이 새록새록해서 재밌었다. 아쉬운 건 prettier가 적용되지 않아 일일이 코드를 칠 때 들여쓰기를 해야해서 불편하다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[15]]></title><description><![CDATA[자바스크립트 패턴과 테스트 팩토리는 객체를 생성하고 반환하는 함수(create…]]></description><link>https://pjaeyoung.github.io/challenge30/15/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/15/</guid><pubDate>Sat, 27 Feb 2021 15:03:16 GMT</pubDate><content:encoded>&lt;h2 id=&quot;자바스크립트-패턴과-테스트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%8C%A8%ED%84%B4%EA%B3%BC-%ED%85%8C%EC%8A%A4%ED%8A%B8&quot; aria-label=&quot;자바스크립트 패턴과 테스트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;자바스크립트 패턴과 테스트&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;팩토리는 객체를 생성하고 반환하는 함수(create)를 가진 객체다. &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;팩토리 패턴을 사용하면 안정적으로 객체를 생성할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;필수 인자들을 체크하는 기능을 갖고 있기 때문에 잘못된 인자를 넘길 가능성을 미리 차단한다.&lt;/li&gt;
&lt;li&gt;new 연산자를 사용해 생성자 함수를 호출해야한다는 사실을 대신 기억해준다. &lt;/li&gt;
&lt;li&gt;다른 언어의 오버라이딩 기능처럼 들어온 인자에 따라 유형별 객체를 생성할 수 있다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;팩토리 패턴의 테스트 포인트는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;필수 인자가 아닌 경우 에러를 발생하는가?&lt;/li&gt;
&lt;li&gt;인자에 대응하는 생성자 함수를 정확히 호출하는가?&lt;/li&gt;
&lt;li&gt;반환값은 생성자 함수의 반환값인가? (&lt;code class=&quot;language-text&quot;&gt;mockReturnValue&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[14]]></title><description><![CDATA[자바스크립트 패턴과 테스트 메모이제이션 패턴은 들어온 인자를 키로 잡고 도출된 결과를 저장하는 자료구조를 사용하고 이후 같은 인자가 들어올 때 다시 계산하는 대신 데이터 컬렉션에 저장된 결과를 반환하는 패턴이다.  외부 api…]]></description><link>https://pjaeyoung.github.io/challenge30/14/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/14/</guid><pubDate>Fri, 26 Feb 2021 16:02:57 GMT</pubDate><content:encoded>&lt;h2 id=&quot;자바스크립트-패턴과-테스트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%8C%A8%ED%84%B4%EA%B3%BC-%ED%85%8C%EC%8A%A4%ED%8A%B8&quot; aria-label=&quot;자바스크립트 패턴과 테스트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;자바스크립트 패턴과 테스트&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;메모이제이션 패턴은 들어온 인자를 키로 잡고 도출된 결과를 저장하는 자료구조를 사용하고 이후 같은 인자가 들어올 때 다시 계산하는 대신 데이터 컬렉션에 저장된 결과를 반환하는 패턴이다. &lt;/li&gt;
&lt;li&gt;외부 api에서 호출 횟수당 가격을 매기는 경우 비용을 아끼기 위해 메모이제이션을 사용하는 예시를 보여준다. &lt;/li&gt;
&lt;li&gt;간단하게 객체를 사용하여 구현할 수 있다. 인자를 &lt;code class=&quot;language-text&quot;&gt;JSON.stringingfy&lt;/code&gt;를 써서 문자열로 변환 후 key가 있는지 확인한다. 인자의 자료형이 문자열로 국한되어있지 않기 때문에 확장성을 고려했다. &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메모이제이션 패턴을 테스트할 때 두 가지를 확인해야 한다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;첫째, 같은 인자로 여러 횟수에 걸쳐서 함수를 호출해도 외부 api 호출 함수 혹은 그 밖에 비용이 많이드는 함수는 단 한 번 호출했는가? &lt;/li&gt;
&lt;li&gt;둘째, 같은 인자로 여러 횟수에 걸쳐서 함수를 호출해도 결과는 동일한가?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;메모이제이션 패턴의 재사용성을 위해 AOP와 결합해서 확장시켰다. AOP로 감싼 경우 추적의 어려운 점 때문에 확장 전에 &lt;code class=&quot;language-text&quot;&gt;spyOn&lt;/code&gt;으로 추적장치를 달고 반환값을 보관하여 테스트를 진행해야 한다. &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;유튜버-엘리---성장하는-개발자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9C%A0%ED%8A%9C%EB%B2%84-%EC%97%98%EB%A6%AC---%EC%84%B1%EC%9E%A5%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90&quot; aria-label=&quot;유튜버 엘리   성장하는 개발자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;유튜버 엘리 - 성장하는 개발자&lt;/h2&gt;
&lt;p&gt;어떻게 해야 ‘완만한’ 경사를 이루더라도 그래프가 올라가는 형태의 성장을 할 수 있을까 고민이 많은 시점이다. 그는 자신의 실수를 직면하고 더 나은 행동으로 나아가는 노력을 하는데 탁월한 사람이다. 부끄럽고 창피해서 잊어버리려는 나와 달리 그는 세세하게 어떤 실수를 했고 그 실수를 다시 반복하지 않기 위해 어떻게 해야 할지 반성의 글을 꾸준히 써내려갔다. 일명 실수노트를 작성했다. 그는 자기를 평가 받는 것을 두려워하지 않았다. 피드백을 하는 문화가 아닌 직장에서도 주기적으로 자신이 어떤 점이 좋고 어떤 점이 아쉬운 지를 묻고 보완해 나갔다. 그가 나처럼 성급하게 일을 해치우려 해서 이후에 버그로 인해 고생을 한 적이 있다고 해서 공감이 갔다. 부트캠프에 있었을 때 잊었던 나의 습관, 어떤 문제를 발견하면 그 문제를 해결하기 위한 노력들을 서술하고 도저히 실마리가 보이지 않을 때 해당 내용을 바탕으로 도움을 요청하는 습관을 다시 갖춰야 겠다는 다짐을 한다. 조만간 이력서를 쓸 일이 있다. 이 기회에 내가 그동안 회피했던 부끄러운 나를 들쳐내어 반성하고 앞으로의 개발자로서 태도를 갖추기 위한 노력을 하기 위한 기회를 삼아야 겠다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[13]]></title><description><![CDATA[…]]></description><link>https://pjaeyoung.github.io/challenge30/13/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/13/</guid><pubDate>Wed, 24 Feb 2021 19:03:15 GMT</pubDate><content:encoded>&lt;h2 id=&quot;인사담당자가-말하는-개발자-채용-프로세스&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B8%EC%82%AC%EB%8B%B4%EB%8B%B9%EC%9E%90%EA%B0%80-%EB%A7%90%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%B1%84%EC%9A%A9-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4&quot; aria-label=&quot;인사담당자가 말하는 개발자 채용 프로세스 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;인사담당자가 말하는 개발자 채용 프로세스&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;요즘은 이력서 퀄리티가 평균적으로 깔끔하고 잘 되어있음
다만, &lt;strong&gt;개발자의 스토리&lt;/strong&gt;를 신경쓰면 좋겠다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현 시점에서 이직/구직하는 이유, 갈증,동기, 업무성향, 커리어 플랜  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인터뷰를 마음 편하게 가지기 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이직/구직의 답이 되는가 찾아가는 과정 &lt;/li&gt;
&lt;li&gt;과거의 경험 질문 : 실제 현업에서 어떤 행동을 하는가? (실패라면 회고 및 개선 행동 고민 얘기하면 좋음)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;체크포인트&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;후보자의 pain point, career vision에 대해 이야기 나누기&lt;/li&gt;
&lt;li&gt;과거 커리어의 태도 기반 상황에서 어떻게 대처했는지 들어보기(Situation - Task - Action - Result)&lt;/li&gt;
&lt;li&gt;준비한 답변을 벗어나 무방비 상태의 내면 이끌기&lt;/li&gt;
&lt;li&gt;우리 회사의 High performer의 태도적 특성과 비교해보기&lt;/li&gt;
&lt;li&gt;현재 커리어에서 채워지지 않는 성취동기를 충족할 수 있다는 기대를 심어주기&lt;/li&gt;
&lt;li&gt;우리의 진정성에 대한 의심을 지워주기 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;자바스크립트-패턴과-테스트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%8C%A8%ED%84%B4%EA%B3%BC-%ED%85%8C%EC%8A%A4%ED%8A%B8&quot; aria-label=&quot;자바스크립트 패턴과 테스트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;자바스크립트 패턴과 테스트&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코딩기술과 이 책을 읽고 부분적용함수에 대한 정리를 하면 이렇다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단순히 필요로 하는 인자들을 한 번에 받지 않고 나누어 받는 기법은 커링&lt;/li&gt;
&lt;li&gt;부분적용함수는 상수 인자들을 감싸고 변수 인자를 받는 함수를 반환하여 함수 실행을 지연시키는 기법이다. &lt;/li&gt;
&lt;li&gt;값이 고정된 인자들을 매번 받기보다 단 한 번 받은 후 변경되는 인자를 나중에 받아 최종적으로 필요로하는 모든 인자를 넘겨 함수를 실행한다. &lt;/li&gt;
&lt;li&gt;테스트할 때는 상수 인자들이 제대로 들어왔는지 확인한다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[12]]></title><description><![CDATA[자바스크립트 패턴과 테스트 프라미스(Promise)는 비동기 작업을 감싼 객체로 비동기 작업 후 작업을 위한 함수를 각각 then, catch…]]></description><link>https://pjaeyoung.github.io/challenge30/12/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/12/</guid><pubDate>Wed, 24 Feb 2021 15:02:55 GMT</pubDate><content:encoded>&lt;h2 id=&quot;자바스크립트-패턴과-테스트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%8C%A8%ED%84%B4%EA%B3%BC-%ED%85%8C%EC%8A%A4%ED%8A%B8&quot; aria-label=&quot;자바스크립트 패턴과 테스트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;자바스크립트 패턴과 테스트&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프라미스(Promise)는 비동기 작업을 감싼 객체로 비동기 작업 후 작업을 위한 함수를 각각 then, catch 메서드의 인자에 넘겨주면 비동기 작업이 완료될 시&lt;br&gt;
작업 결과(성공/실패)에 따라 콜백함수를 실행한다. &lt;/li&gt;
&lt;li&gt;프라미스는 주로 외부 API와 연관된 함수를 테스트할 때 활용된다. &lt;/li&gt;
&lt;li&gt;비동기 테스트를 할 때 반드시 &lt;code class=&quot;language-text&quot;&gt;it(&amp;#39;테스트할 기능 서술&amp;#39;,(done)=&amp;gt;{})&lt;/code&gt; 의 ‘done’ 콜백함수를 실행시켜야 한다. &lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;jest.fn(테스트용 함수)&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;jest.spyOn(객체,속성명).mockImplementaion(테스트용 함수)&lt;/code&gt;를 사용하여 실제 외부 API와 상호작용하는 로직을 대체할 테스트용 함수를 바꿔치기할 수 있다. &lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[11]]></title><description><![CDATA[자바스크립트 패턴과 테스트 콜백 패턴의 경우 테스트를 할 때 고려해야 할 사항은 3가지가 있다.  첫째, 콜백 호출 횟수다. 가령 배열 메서드 forEach에서 사용하는 콜백의 경우 콜백호출 횟수가 곧 배열 메서드 길이와 같아야 한다. 
jest…]]></description><link>https://pjaeyoung.github.io/challenge30/11/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/11/</guid><pubDate>Tue, 23 Feb 2021 15:02:24 GMT</pubDate><content:encoded>&lt;h2 id=&quot;자바스크립트-패턴과-테스트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%8C%A8%ED%84%B4%EA%B3%BC-%ED%85%8C%EC%8A%A4%ED%8A%B8&quot; aria-label=&quot;자바스크립트 패턴과 테스트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;자바스크립트 패턴과 테스트&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;콜백 패턴의 경우 테스트를 할 때 고려해야 할 사항은 3가지가 있다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;첫째, 콜백 호출 횟수다. 가령 배열 메서드 forEach에서 사용하는 콜백의 경우 콜백호출 횟수가 곧 배열 메서드 길이와 같아야 한다.
jest를 사용한다면 &lt;code class=&quot;language-text&quot;&gt;jest.fn&lt;/code&gt;으로 테스트용 콜백함수를 생성한 후 &lt;code class=&quot;language-text&quot;&gt;toHaveBeenCalledTimes&lt;/code&gt; 단언문으로 검사한다.  &lt;/li&gt;
&lt;li&gt;둘째, 콜백에 넘겨진 인자를 확인한다. 배열 메서드 forEach를 제대로 돌았다면 테스트용 콜백함수의 기록사항에서 마주친 값들이 배열요소 순서대로 인지 확인한다.
&lt;code class=&quot;language-text&quot;&gt;toHaveBeenNthCalledWith(호출 회, 배열요소)&lt;/code&gt; 단언문으로 검사한다. &lt;/li&gt;
&lt;li&gt;셋째, 검사하고자 하는 메서드 안에서 ‘this’가 사용된다면 this가 아닌 경우를 검사해야 한다. 위의 두 사항과 달리 실제로 콜백으로 넘겨줄 함수 그 자체만 검사하는 용도다. &lt;code class=&quot;language-text&quot;&gt;call, apply, bind&lt;/code&gt; 메서드로 ‘this’ 값을 임의로 바꿔서 검사한다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[10]]></title><description><![CDATA[<자바스크립트 패턴과 테스트> 책을 읽고 있다. 테스트 주도 개발(TDD)를 꿈꿨지만 막상 작성하려고 하면 어설프고 제대로 하고 있는지 몰라 막막했다.
블로그 글들을 둘러봐도 TDD…]]></description><link>https://pjaeyoung.github.io/challenge30/10/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/10/</guid><pubDate>Sun, 21 Feb 2021 16:03:00 GMT</pubDate><content:encoded>&lt;p&gt;&amp;#x3C;자바스크립트 패턴과 테스트&gt; 책을 읽고 있다. 테스트 주도 개발(TDD)를 꿈꿨지만 막상 작성하려고 하면 어설프고 제대로 하고 있는지 몰라 막막했다.
블로그 글들을 둘러봐도 TDD의 개념 위주로 설명하거나 과정을 생략하여 테스트 코드를 보여주는 식으로만 보여준다. 이 책은 테스트를 작성하는 과정을
상세히 단계적으로 보여주어 같이 코드를 따라 치다보면 그 흐름에 나도 동참하는 듯한 기분(내가 글쓴이가 된 느낌이랄까)이 든다. 빨리 읽고 끝낼 생
각이었는데 시간을 들여 꼼꼼히 보도록 계획을 수정해야겠다.  &lt;/p&gt;
&lt;p&gt;TDD를 할 때 제일 중요한 점은 실제 코드가 테스트보다 앞서면 안 된다는 것이다.
실패하는 코드를 먼저 작성하라는 의미가 바로 이것이다. 실제 코드가 없으니 당연히 테스트가 실패하지 않겠는가?
테스트도 한 번에 생각해둔 모든 기능을 테스트하는 코드를 작성하지 않고 최소한의 기능 테스트를 작성해야 한다. 그렇다고 아무 생각없이 무작정
테스트를 작성하는 게 아니라 미리 어떤 기능들이 필요한지 그리고 그 기능을 실행시키기 위한 단계가 무엇인지 나름대로의 명세서를 작성해야 한다.
가령 권한 여부에 따라 성공/실패 여부에 대한 알림 메세지를 출력하는 로직을 작성하고자 한다고 치자. &lt;/p&gt;
&lt;p&gt;맨 처음엔 인자가 제대로 들어왔는지 예외처리부터 시작한다. 즉 인자 ‘권한여부’라는 값이 undefined인지 boolean형이 아닌지를
판단하고 제대로된 인자가 아니면 에러를 발생할 것을 기대하는 테스트를 작성한다. 당연히 내부 구현이 없기 때문에 실패한다.
이제 이 테스트를 통과하기 위해 최소한의 코드를 작성한다. 통과가 되었다면 다음 테스트를 작성한다. 그리고 또 최소한의 코드를 작성하여 테스트를
통과한다. &lt;/p&gt;
&lt;p&gt;책에서는 &lt;code class=&quot;language-text&quot;&gt;describe&lt;/code&gt;는 주로 클래스명 -&gt; 함수명 와 같이 큰 개념에서 작은 개념, 큰 분류에서 작은 분류로 작성한다.
예전 내가 하던 방식은 &lt;code class=&quot;language-text&quot;&gt;alertByAuthority 함수 테스트&lt;/code&gt; 였는데 이 책은 &lt;code class=&quot;language-text&quot;&gt;alertByAuthority(authorized,alert)&lt;/code&gt; 함수의 인터페이스를
적는다. 아마도 테스트 코드를 작성할 때 어떤 인자를 넘겨야 할지 헛갈리지 않도록 하기 위함이지 않을까 한다. &lt;/p&gt;
&lt;p&gt;테스트 흐름 뿐만 아니라 고급 자바스크립트 기술도 알려준다. SOLID 원칙 중 개방/폐쇄 원칙을 지키기 위한 방법 중 하나인 AOP를 소개한다.
이전에 만들어 둔 함수에 추가적인 기능을 덧붙여 사용하고 싶을 때 해당 함수를 수정하지 않는다. 해당 함수를 수정하면 테스트도 수정해야 하기 때문에
일이 배로 늘어나고 작은 수정이라 비슷한 테스트 코드를 ‘반복’하여 작성해야 하기 때문에 반복을 최소화하라는 DRY 원칙에도 어긋난다. AOP는 새로운
애스팩트(관심)을 수행하는 코드를 기존 함수 실행 코드와 묶어 새로운 함수로 감싸는 기법이다. 내부 수정 없이 기능을 확장하는 방향으로 코드를 작성
할 수 있게 된다. 테스트 코드도 마찬가지로 기존 함수를 테스트하는 코드를 그대로 두고 감싼 함수만 테스트하는 코드를 작성하면 된다. &lt;/p&gt;
&lt;p&gt;아직 초반부까지 읽었는데도 TDD 방식이 자연스럽게 관심사를 좁히고 의존성 주입을 활용하는 등 유연한 코드를 작성하도록 유도한다는 걸 몸소 느끼고
있다. 처음부터 100% 흡수할 거라 욕심내지 않고 조금씩 쌓아가자. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[09]]></title><description><![CDATA[코드스테이츠 폴빈님 토크 세션 80-20 내용 정리 회사가 원하는 것은 무엇일까? 기업의 성숙도가 높을수록 실무능력보다 CS를 중시  스타트업은 과제를 주로 냄  어떤 기술을 쓰더라도 깊게 파고들기, 면접시 깊고 상세하게 대답하는 것을 좋아함 (T…]]></description><link>https://pjaeyoung.github.io/challenge30/09/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/09/</guid><pubDate>Fri, 19 Feb 2021 19:02:04 GMT</pubDate><content:encoded>&lt;h2 id=&quot;코드스테이츠-폴빈님-토크-세션-80-20&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%BD%94%EB%93%9C%EC%8A%A4%ED%85%8C%EC%9D%B4%EC%B8%A0-%ED%8F%B4%EB%B9%88%EB%8B%98-%ED%86%A0%ED%81%AC-%EC%84%B8%EC%85%98-80-20&quot; aria-label=&quot;코드스테이츠 폴빈님 토크 세션 80 20 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;코드스테이츠 폴빈님 토크 세션 80-20&lt;/h2&gt;
&lt;h3 id=&quot;내용-정리&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC&quot; aria-label=&quot;내용 정리 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;내용 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;회사가 원하는 것은 무엇일까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기업의 성숙도가 높을수록 실무능력보다 CS를 중시 &lt;/li&gt;
&lt;li&gt;스타트업은 과제를 주로 냄 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;어떤 기술을 쓰더라도 깊게 파고들기, 면접시 깊고 상세하게 대답하는 것을 좋아함 (T자형 인재)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;집중하라!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vanilla Javascript &amp;#x26; SQL &amp;#x26; Algorithm &amp;#x26; CS 기본 &lt;/li&gt;
&lt;li&gt;내가 하는 일에 관심 갖기 &lt;/li&gt;
&lt;li&gt;내가 관심을 갖고 있다는 것을 증명하기&lt;/li&gt;
&lt;li&gt;큰 개념 -&gt; 작은 부수 개념 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스스로에 대해 이해하기 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내가 제어할 수 있는 부분이랑 없는 부분 이해하기 ex) 경력, 학력&lt;/li&gt;
&lt;li&gt;내 장단점을 명확하게 이해하기&lt;/li&gt;
&lt;li&gt;내 적성에 맞는 것 찾기&lt;/li&gt;
&lt;li&gt;이 외에 회사에 어떠한 가치를 제공해줄 수 있는가 생각하기&lt;/li&gt;
&lt;li&gt;내 North Star 가 무엇인지 생각해보기 (내가 어떤 삶을 추구하는가)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;‘주니어’가 되지 마세요&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;본인 스스로 경력자라는 사실을 부정하지 말기&lt;/li&gt;
&lt;li&gt;스스로의 영역을 한정짓지 않기 &lt;/li&gt;
&lt;li&gt;이른바 “주니어에 대한 기대치”에 집착하지 않기&lt;/li&gt;
&lt;li&gt;내가 회사에 어떠한 가치를 제공해줄 수 있는가 생각하기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;학습은 절대 Linear하지 않습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음부터 100% 학습 불과&lt;/li&gt;
&lt;li&gt;많이 할 수록 점차 알아감  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;할 일을 만들어라&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2% 부족한 점을 찾고 추가하기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;링크드인 글을 많이 올려보자! =&gt; 인맥과 취업 통로에 좋다 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;후기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%9B%84%EA%B8%B0&quot; aria-label=&quot;후기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;후기&lt;/h3&gt;
&lt;p&gt;전 회사에서 신입을 뽑기 위해 면접에 여러 번 참여할 기회가 있었다.
면접관의 입장에서 지원자를 평가할 때 눈에 띈다고 생각했던 지원자들은 단순 암기식으로 대답하는 사람들이 아니라
해당 용어나 개념에 대해서 골몰해보았고 자신의 언어로 표현할 줄 아는 사람이었다. 그 덕에 다시 취준생으로 돌아온
지금 면접 준비를 어떻게 해야 할 지 감을 잡을 수 있었다. 새롭게 알게 되었거나 가물가물해진 개념들이 있는데 코딩
하면서 찾게 된다면 요리조리 뜯어보고 조립해 보는 기회로 삼아야겠다.
나는 테스트 주도 개발과 인터렉티브 웹에 관심이 있다. 그러나 그 관심을 증명할 프로젝트 혹은 글, 영상이 없다.
아무리 나는 관심이 있다고 호소해도 눈으로 보여지는 결과물이 없다면 소용없다. 토이 프로젝트 등을 통해 블로그/SNS 그리고
유튜브 매체를 활용하여 조금씩 나는 이런 사람임을 보여주자.
TDD 관련 책과 인터렉션 강좌를 2월 달 안으로 끝내고 이를 바탕으로 프로젝트를 진행할 생각이다.
어떤 식으로 나를 PR해야 하는가.
프로젝트 하면서 어떤 식으로 테스트를 작성해왔고, 어떤 문제를 부딪혔을 때 어떤 사고과정과 참고자료로 해결했는지를 통해
‘문제 해결력이 있는 개발자’, ‘안정성, 확장성, 유지보수성을 추구하는 개발자’를 보여준다.
재밌는, 신기한 인터렉션을 보여주는 사이트가 있으면 보관해뒀다가 ‘클론’하여 그 방법/과정을 작성하고 영상으로 제작하여
공유한다.
&lt;/p&gt;</content:encoded></item><item><title><![CDATA[08]]></title><description><![CDATA[노마드 투두리스트 대회 참여 1. 결과물 URL https://pjaeyoung.github.io/momontum/ intro
main_1
main_2…]]></description><link>https://pjaeyoung.github.io/challenge30/08/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/08/</guid><pubDate>Tue, 16 Feb 2021 00:02:36 GMT</pubDate><content:encoded>&lt;h2 id=&quot;노마드-투두리스트-대회-참여&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%85%B8%EB%A7%88%EB%93%9C-%ED%88%AC%EB%91%90%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%8C%80%ED%9A%8C-%EC%B0%B8%EC%97%AC&quot; aria-label=&quot;노마드 투두리스트 대회 참여 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;노마드 투두리스트 대회 참여&lt;/h2&gt;
&lt;h3 id=&quot;1-결과물-url&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EA%B2%B0%EA%B3%BC%EB%AC%BC-url&quot; aria-label=&quot;1 결과물 url permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 결과물 URL&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://pjaeyoung.github.io/momontum/&quot;&gt;https://pjaeyoung.github.io/momontum/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/47022167/107963473-91db5400-6feb-11eb-84f8-9a9a310687e8.gif&quot; alt=&quot;intro&quot;&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/47022167/107963456-8be57300-6feb-11eb-9d79-9e5a4462b0d5.gif&quot; alt=&quot;main_1&quot;&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/47022167/107963449-89831900-6feb-11eb-9c71-0ea71dfa65d7.gif&quot; alt=&quot;main_2&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-서비스-소개&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%86%8C%EA%B0%9C&quot; aria-label=&quot;2 서비스 소개 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 서비스 소개&lt;/h3&gt;
&lt;p&gt;처음 닉네임을 입력하면 투두화면으로 전환합니다. &lt;/p&gt;
&lt;p&gt;닉네임을 한 글자 입력하자마자 이모티콘이 윙크를 해줍니다.(  0.^ )&lt;/p&gt;
&lt;p&gt;화면 전환도 심심하지 않게 위로 화면이 옮기면서 점차 사라지는 효과를 줬습니다.&lt;/p&gt;
&lt;p&gt;투두화면에서 입력하신 닉네임으로 환영인사를 해줍니다.&lt;/p&gt;
&lt;p&gt;환영인사는 momentum 이 설정한 기준대로 시간별(Good Morning, Good Afternoon, Good Evening)로 바뀝니다.  그리고 타이핑 효과를 주었습니다.&lt;/p&gt;
&lt;p&gt;시계는 시/분으로 매분 변경하게 했습니다. &lt;/p&gt;
&lt;p&gt;할 일을 입력하면 화면이 회전하는 효과를 넣어 재미를 줬습니다. &lt;/p&gt;
&lt;p&gt;할 일 에 마우스를 가져다 대면 3d 효과를 적용하여 뒤에 숨겨둔 삭제버튼을 보여줍니다.&lt;/p&gt;
&lt;p&gt;삭제 버튼을 클릭하면 할 일이 지워집니다.&lt;/p&gt;
&lt;p&gt;한 번 입력한 닉네임과 할 일 목록은 localStorage 에 영구 저장합니다. &lt;/p&gt;
&lt;h3 id=&quot;3-개발과정-어려웠던-점과-해결방법&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EA%B0%9C%EB%B0%9C%EA%B3%BC%EC%A0%95-%EC%96%B4%EB%A0%A4%EC%9B%A0%EB%8D%98-%EC%A0%90%EA%B3%BC-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95&quot; aria-label=&quot;3 개발과정 어려웠던 점과 해결방법 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 개발과정 (어려웠던 점과 해결방법)&lt;/h3&gt;
&lt;p&gt;투두를 입력하는 중에 화면이 회전하게 만들 때 어려웠습니다. &lt;/p&gt;
&lt;p&gt;처음에는 입력한 길이 만큼 오른쪽으로 회전하다 일정 길이가 지나면 왼쪽으로 회전하고 &lt;/p&gt;
&lt;p&gt;이 과정을 반복하고 싶은데 (시소처럼?) if문으로 예외처리를 계속하자니 얼만큼 입력할 지 모르는 상태에서 비효율적이라고 생각이 들었습니다. &lt;/p&gt;
&lt;p&gt;그래서 입력한 길이 대신 max 값을 두어 max값과 0값을 오가면서 좌우로 움직이도록 구현했습니다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[07]]></title><description><![CDATA[<자바스크립트 코딩의 기술> 요약 정리 08장 클래스로 인터페이스를 간결하게 유지하라  es…]]></description><link>https://pjaeyoung.github.io/challenge30/07/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/07/</guid><pubDate>Thu, 11 Feb 2021 17:02:56 GMT</pubDate><content:encoded>&lt;h3 id=&quot;자바스크립트-코딩의-기술-요약-정리&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%BD%94%EB%94%A9%EC%9D%98-%EA%B8%B0%EC%88%A0-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC&quot; aria-label=&quot;자바스크립트 코딩의 기술 요약 정리 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&amp;#x3C;자바스크립트 코딩의 기술&gt; 요약 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;08장 클래스로 인터페이스를 간결하게 유지하라 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;es6부터 지원되는 클래스는 전혀 새로운 문법이 아니라 기존의 프로토타입으로 속성과 메서드를 상속하는 방식을 다른 객체 지향 언어의 클래스 형식을 차용한 문법이다. 다만 자바스크립트의 독특한 this의 성질은 남아있기 때문에 주의해야 한다. &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클래스의 constructor 함수는 생성자 함수 역할을 한다. constructor 함수 안에서 속성을 추가한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현재까지 자바스크립트는 공식적으로 private 속성을 지원하지 않는다. 어디서든 속성값에 곧바로 접근해서 값을 수정할 수 있다는 취약점은 원래 의도했던 데이터 형태를 훼손(가령, string이었던 속성값을 number로 변경)할 가능성으로 이어진다. &lt;/li&gt;
&lt;li&gt;private 속성 대신 컨벤션과 getter, setter 메서드로 취약점을 보완한다. 속성명 맨 앞은 언더바(_)를 적어 private한 속성임을 명시한다. 외부에서 사용할 때는 동일한 이름의 get, set 메서드 형식으로 표현한다. 클래스 내부는 메서드 형식이지만 외부에서는 마치 속성처럼 접근할 수 있다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클래스의 메서드 안에서 인자로 this에 접근하는 콜백함수를 받는 함수를 실행할 때 아무 조치가 없다면 this는 객체 인스턴스가 아닌 global, window 객체를 가리킨다. this는 오직 생성자 함수와 메서드 내에서(메서드 몸체 안에 곧바로)만 인스턴스에 접근할 수 있기 때문이다. 이 경우 bind를 사용하여 this를 인스턴스로 묶어주면 된다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;여러 메서드를 걸쳐 사용된다면 생성자 함수에서 bind로 단 한 번만 묶어준다. 혹은 화살표 함수를 사용한다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;제너레이터는 함수 실행을 중간에 멈추고 반환하는 함수다. 복잡한 객체 형태(중첩객체)를 순회할 때 유용하다. 클래스 메서드 형태는 &lt;code class=&quot;language-text&quot;&gt;*[Symbol.iterator](){}&lt;/code&gt; 이고 반복문을 사용해서 중첩 객체에 접근하는 로직을 작성한다. 외부에서는 &lt;code class=&quot;language-text&quot;&gt;for ... of&lt;/code&gt; 나 spread operator를 사용한 분해 할당이 가능하다.       &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[06]]></title><description><![CDATA[<자바스크립트 코딩의 기술> 요약 정리 0…]]></description><link>https://pjaeyoung.github.io/challenge30/06/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/06/</guid><pubDate>Wed, 10 Feb 2021 14:02:16 GMT</pubDate><content:encoded>&lt;h3 id=&quot;자바스크립트-코딩의-기술-요약-정리&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%BD%94%EB%94%A9%EC%9D%98-%EA%B8%B0%EC%88%A0-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC&quot; aria-label=&quot;자바스크립트 코딩의 기술 요약 정리 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&amp;#x3C;자바스크립트 코딩의 기술&gt; 요약 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;07장 유연한 함수를 만들어라 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개인적으로 가장 습득하고 싶은 고급 기술들(내 기준에서)을 소개하고 있다. 의존성 주입/고차함수(부분적용함수, 커링)는 함수의 재사용성을 높이고 각 함수가 제어해야 할 변수들을 줄여준다. &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테스트하기 쉬운 함수란 순수함수 즉, 외부와 소통할 수 있는 유일한 창구인 인자를 가지고 결과물을 반환하는 함수다. 함수 안에서 또 다른 함수를 호출하는 경우가 종종 있는데 이 경우 내부 함수가 외부 api를 요청하거나 비동기적으로 작동할 때 테스트를 작성하기가 까다로워진다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sinon 라이브러리의 stub, mock, spy 와 같은 헬퍼 함수(jest의 경우 spyOn, fn, mock)를 사용하여 해결한다. &lt;/li&gt;
&lt;li&gt;이보다 더 간단한 방법은 내부에 뒀던 함수를 밖으로 꺼내어 그 결과물을 인자로 받도록 구현하는 것이다. 이를 &lt;strong&gt;의존성 주입&lt;/strong&gt; 이라 일컫는다.&lt;/li&gt;
&lt;li&gt;헬퍼 함수를 많이 쓴다는 것은 그만큼 코드가 복잡하고 의존성이 크다는 증거이다. 테스트를 작성하기 전에 코드를 리팩토링해야 할 시점인지 의심해봐야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;고차함수는 인자로 함수를 받거나 함수를 반환하는 함수를 일컫는다. 고차함수의 특징을 이용해서 인자들을 받을 시기를 늦출 수 있다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;부분 적용 함수와 커링은 원래 받아야 할 인자 개수 보다 적은 인자를 받는 함수를 반환하는 함수를 의미한다. 커링은 인자 개수를 하나로 고정하는 특징이 있다. &lt;/li&gt;
&lt;li&gt;만약 같은 인자를 반복적으로 넘겨서 작업하는 함수가 있다면 부분적용 함수나 커링으로 리팩토링해볼 가치가 있다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;자바스크립트에서 this는 문맥에 따라 값이 달라진다. 객체 메서드에서 객체 속성값을 this로 접근한 채 콜백 함수로 넘길 경우 객체 인스턴스의 문맥을 상실하고 global객체(window객체)를 가리키게 되어 오작동을 하게 된다. 이때 콜백 함수를 화살표 함수로 사용하면 바로 상위의 스코프에서 가리키는 this 즉, 객체 인스턴스를 유지한다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[05]]></title><description><![CDATA[06 장 매개변수와 return…]]></description><link>https://pjaeyoung.github.io/challenge30/05/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/05/</guid><pubDate>Tue, 09 Feb 2021 14:03:36 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;06 장 매개변수와 return 문을 정리하라 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발하면서 흔히 겪는 일 중의 하나가 기존에 만든 함수를 확장하는 일이다. 하나만 받던 인자를 두 개, 세 개씩 추가해야 할 때 해당 함수가 쓰인 모든 파일을 찾아서 값을 넘겨주는 일은 번거로우며 깜빡 잊고 건너뛰어버릴 수 있다. 차라리 수정하는 함수 안에서 예외처리를 하는 편이 낫다. undefined인 경우를 따져 삼항연산자나 단락평가를 해서 기본값을 지정해도 인자가 많아질 수록 코드가 장황해진다. 이때 매개변수 기본값을 사용하면 중괄호 안에서 undefined 인지 판단하는 과정과 기본값 설정하는 과정을 압축할 수 있다. &lt;/li&gt;
&lt;li&gt;매개변수 기본값 설정의 단점은 인자를 순서대로 넘겨야 하기 때문에 중간을 비워둘 수 없다는 점이다. undefined를 직접 넘겨줘도 되지만 인자 개수가 많아지면 순서가 헷갈려 실수할 가능성이 높다. &lt;/li&gt;
&lt;li&gt;객체의 해체할당을 통해서 필요한 인자만 넘겨줄 수 있다. 해체 할당은 마치 변수를 새롭게 선언하듯 사용하며 중괄호({})로 감싸 객체의 속성임을 표시한다. 변수명은 반드시 객체에 지정한 속성명과 일치해야 한다. 만약 속성명과 일치하지 않으면 undefined 값이 나온다. &lt;/li&gt;
&lt;li&gt;해체 할당과 더불어 spread operator를 같이 사용하면 일부 속성만 변경한 새로운 객체를 생성할 때 편리하다. 값이나 명칭을 변경할 속성만 해체 할당하고 나머지는 spread operator로 가져와 반환 할 중괄호({})에 원하는 형태로 재할당을 한다. &lt;/li&gt;
&lt;li&gt;배열의 해체 할당은 대괄호([]) 안에서 맨 앞의 항목 부터 변수 처럼 선언하여 가져올 수 있다. spread operator를 사용하면 일부 항목은 변수처럼 가져와 사용하고 나머지는 배열 형태를 유지하여 사용할 수 있다. &lt;/li&gt;
&lt;li&gt;rest parameter는 정확히 개수를 알 수 없는 여러 자료형들의 인자들을 배열 형태로 묶어서 가져올 때 사용한다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[04]]></title><description><![CDATA[05장 반복문을 단순하게 만들어라  for…]]></description><link>https://pjaeyoung.github.io/challenge30/04/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/04/</guid><pubDate>Mon, 08 Feb 2021 14:03:30 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;05장 반복문을 단순하게 만들어라 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;for문 대신 배열 메서드를 사용하는 편이 좋다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변수를 새롭게 할당하는 과정을 생략할 수 있다. &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;관심사를 하나로 줄일 수 있다. 한 가지 기능을 수행하기 때문에 자세히 코드를 들여다보지 않아도 메서드만 보고 반환 형태가 어떠할 지 예측 가능하다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;map() : 같은 길이, 변경된 형태로 반환. 주로 객체의 일부 속성으로 이뤄진 배열을 생성할 때 사용한다. &lt;br/&gt;
filter() : 형태 유지, 변경된 길이를 반환. 주로 특정 조건에 해당하는 배열 항목들로 이뤄진 새로운 배열을 생성할 때 사용한다. &lt;br/&gt;
find() : 단 하나만 있을 거라 예상되는 항목이거나 하나만 필요할 때 사용한다. 조건에 맞는 항목이 없을 경우 undefined를 반환한다. 이 경우 단락 평가(|| 연산자)로 const 변수 할당을 유지할 수 있다.&lt;br/&gt;
forEach() : 형태나 길이 변형 없이 배열 항목에 같은 동작을 실행할 때 사용한다.다른 배열 메서드와 달리 외부 조작으로 이어지나 체이닝을 적용하여 이전에 처리한 결과값을 따로 변수를 할당하여 저장할 필요를 줄여준다. &lt;br/&gt;
reduce() : 길이와 형태 모두 변경할 수 있다. 다른 배열 메서드와 달리 콜백함수에 두 번째 인자(배열 항목)를 필수 인자로 받는다. reduce 메서드의 두 번째 인자에서 누적값의 초기 형태를 지정할 수 있다. 반환값 형태를 예측가능하게 해주기 때문에 되도록 초기 형태를 지정할 것을 권장한다.   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;때때로 컬렉션을 배열로 변환하는 과정이 번거로울 수 있다. 이 경우 &lt;code class=&quot;language-text&quot;&gt;for ... of&lt;/code&gt; 문을 사용하면 형변환 없이 각각의 값들을 순회할 수 있다. &lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;for ... in&lt;/code&gt; 문은 객체의 모든 열거 가능한 키 값들을 순회할 수 있게 해준다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[03]]></title><description><![CDATA[04장 조건문을 깔끔하게 작성하라 조건식을 작성할 때 자바스크립트의 문법 상  를 falsy한 값으로 여기기 때문에 발생하는 버그를 줄이기 위해서 bool형(true/false…]]></description><link>https://pjaeyoung.github.io/challenge30/03/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/03/</guid><pubDate>Sat, 06 Feb 2021 00:03:34 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;04장 조건문을 깔끔하게 작성하라&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;조건식을 작성할 때 자바스크립트의 문법 상 &lt;code class=&quot;language-text&quot;&gt;&amp;#39;&amp;#39;,null, undefined,0,false&lt;/code&gt; 를 falsy한 값으로 여기기 때문에 발생하는 버그를 줄이기 위해서 bool형(true/false) 체크로 엄격하게 작성할 것을 권장한다.&lt;/li&gt;
&lt;li&gt;짧은 조건식일 경우 삼항 연산자를 사용하면 더 좋다. 특정 변수가 조건에 따라 값이 다르게 할당되어야 할 경우(가령, 나이가 19세 이상일 때 입장여부에 대한 변수) 삼항 연산자를 사용하지 않고 조건문(if)을 작성하면 외부에 let 키워드로 변수를 선언하고 조건문 안에서 할당하는 과정을 거치게 된다. 하지만 삼항연산자는 같은 라인에 조건식에 따라 값을 결정하므로 const 키워드를 사용할 수 있고 예측 가능하고 코드 라인 수를 줄여 작성할 수 있다. &lt;/li&gt;
&lt;li&gt;|| 연산자는 삼항 연산자와 마찬가지로 한줄로 const 키워드 선언 및 할당을 가능하게 만든다. || 연산자 앞의 값이 falsy하다면 || 연산자 뒤의 기본값을 할당하도록 할 수 있다. &lt;/li&gt;
&lt;li&gt;&amp;#x26;&amp;#x26; 연산자는 &amp;#x26;&amp;#x26; 연산자 앞의 조건식이 충족되어야 &amp;#x26;&amp;#x26; 연산자 뒤의 값을 반환하거나 조건식을 진행한다. if문 중첩없이 객체의 속성값이 존재할 때만 속성값에 또 다른 처리를 할 경우 유용하다.       &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[02]]></title><description><![CDATA[하루에 2 장을 읽고 정리하려고 마음을 먹었는데 항상 1장을 겨우 끝낸다. 꾸준히 공부한다는 데 의미를 두고 너무 낙담하지 말자.…]]></description><link>https://pjaeyoung.github.io/challenge30/02/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/02/</guid><pubDate>Thu, 04 Feb 2021 23:03:16 GMT</pubDate><content:encoded>&lt;p&gt;하루에 2 장을 읽고 정리하려고 마음을 먹었는데 항상 1장을 겨우 끝낸다. 꾸준히 공부한다는 데 의미를 두고 너무 낙담하지 말자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;3장 특수한 컬렉션을 이용해 코드 명료성을 극대화하라 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;배열 다음으로 많이 쓰는 객체를 소개했다. 객체를 정적인 키-값 컬렉션으로 바라본 점이 신선했다. 각종 config 파일을 객체 형태로 export하는 예를 들어서 이해가 갔다. 정적인 객체를 프로그래밍적으로 접근하는 방법은 정해진 틀, 구조(키)에 값만 갈아끼우는 식으로 새로 생성하는 함수를 이용하는 것이다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이전 장들에서도 계속 강조했듯 객체에서도 조작을 가하지 않는 방향으로 코드를 작성하길 권한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Object.assign&lt;/code&gt;을 이용하는 방법과 spread operator(…)을 사용하는 방법이 있는데 후자가 훨씬 직관적이고 첫 번째 인자에 빈 객체({})를 할당해야 한다는 주의사항을 기억하지 않아도 된다는 점에서 좋다. 사람의 기억력의 한계, 모든 문법을 기억하기 어려운 점이 오용으로 인한 에러를 낳을 가능성이 크다는 점을 계속해서 강조한다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;만약 키가 유동적으로 변한다면 객체보다는 map 사용을 권장한다. 객체의 경우 키 추가/삭제/전체 삭제 기능을 구현할 때 통일되지 않은 방식(객체 내장 메서드, delete 연산자,빈 객체 재할당)을 취한다. map의 경우 인스턴스의 내장 메서드로 접근(add,delete,clear)한다. 그리고 그 인터페이스(메서드)의 명칭이 기능을 분명히 드러낸다.&lt;/li&gt;
&lt;li&gt;객체는 키와 값을 순회할 때 항상 &lt;code class=&quot;language-text&quot;&gt;Object.keys&lt;/code&gt; 로 키들로 이뤄진 배열로 변환 후 키들의 개수 만큼 순회하여 값을 접근해야 한다. 최근에는 &lt;code class=&quot;language-text&quot;&gt;for ... in&lt;/code&gt; 문법의 도입으로 변환과정의 필요성이 사라졌지만 키 만 접근할 수 있다는 한계가 있다. map은 &lt;code class=&quot;language-text&quot;&gt;for ... of&lt;/code&gt; 에서 키 값 을 튜플형식으로 곧바로 접근할 수 있다. 또한 대괄호([])안에서 spread operator(…)와 함께 사용하면 키 값 튜플형식으로 분리하여 가져올 수 있다. map이 배열 형태로 쉽게 변환할 수 있다는 점은 때때로 키-값 컬렉션을 배열 내장 메서드를 활용해야 할 때 장점이 된다.&lt;/li&gt;
&lt;li&gt;map의 조작/변형을 일으키는 내장 메서드(add, delete,clear)는 원본 손상의 위험(부수효과)이 있기 때문에 항상 spread operator(…)로 map 생성자에 넘겨 복사된 새 map을 만들어 사용한다. &lt;/li&gt;
&lt;li&gt;set은 고유한 값들로 구성된 특수한 배열이다. 하지만 배열과 달리 인덱스 접근은 불가능하다. map과 마찬가지로(add, delete,clear,has)와 같은 내장 메서드를 가지고 있다. 중복된 값들로 구성된 배열을 set의 생성자에 넘겨주면 고유한 값들로 구성된 컬렉션을 반환한다. 이를 다시 대괄호([])안에서 spread operator(…)와 함께 사용하면 중복이 없는 값들로 구성된 배열을 생성할 수 있다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[01]]></title><description><![CDATA[자바스크립트를 제대로 사용해보고 싶어서 조 모건이 쓴 <자바스크립트 코딩의 기술>을 읽고 있다. 
일주일 간 책 내용 복습 위주로 작성하지 않을까싶다.…]]></description><link>https://pjaeyoung.github.io/challenge30/01/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/01/</guid><pubDate>Wed, 03 Feb 2021 22:02:47 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트를 제대로 사용해보고 싶어서 조 모건이 쓴 &lt;u&gt;&amp;#x3C;자바스크립트 코딩의 기술&gt;&lt;/u&gt;을 읽고 있다.
일주일 간 책 내용 복습 위주로 작성하지 않을까싶다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1장 변수 할당으로 의도를 표현하라 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코드 작성 시 변수 할당이 무수히 많이 일어난다. 내가 오늘 작성한 코드에서 몇 번이나 변수를 할당했는지 기억을 많이 할 수 없을 정도다. 가볍게 스치듯 작성하지만 &lt;strong&gt;가장 많이 작성&lt;/strong&gt;하기에 맨 처음 중요하게 다룬다.&lt;/li&gt;
&lt;li&gt;var는 어휘적 범위(lexical scope), let과 const는 블록 범위(block scope)이다. 블록 범위는 주로 중괄호({}) 안에서 유효한 값으로 취급한다는 의미다. 대표적으로 if문, for문이 있다. &lt;/li&gt;
&lt;li&gt;const를 우선으로 쓰고 필요할 때 let을 쓰는 전략을 추천한다. var는 블록 범위가 없다는 점, 재선언이 가능하고 호이스팅(선언부보다 앞서 접근/사용이 가능) 때문에 수 백줄의 긴 코드에서 값의 변화를 예측하기 어렵게 만든다. &lt;/li&gt;
&lt;li&gt;const는 처음 선언할 때 할당한 값을 유지하기 때문에 코드가 길어져도 그 값을 신경쓰지 않아도 된다(배열의 항목과 객체의 속성값은 예외다). const를 많이 쓰면 그만큼 변화가 일어나는 구간이 좁혀지고 신경써야할 변수의 개수가 줄어들어 결과적으로 버그를 발생할 확률을 줄여준다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2장 배열로 데이터 컬렉션을 관리하라&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최신 자바스크립트에서 다양한 데이터 컬렉션이 추가되었다. 그 중에서도 배열이 가장 많이 쓰이는 컬렉션이다. 값을 추가하고 제거하고 필터링하고 수정하는 기본적인 기능을 자체 배열 메소드에서 제공해준다. &lt;/li&gt;
&lt;li&gt;1장에서 const로 변화를 최소화하는데 배열이 예외가 된다고 말했다. 이 배열을 되도록 처음 상태를 유지하면서 프로그래밍하기 위해서는 &lt;strong&gt;사본&lt;/strong&gt;을 만들어 변형을 일으키는 것이다. 여기서 유용한 최신 문법은 전개연산자(spread operator)다. &lt;/li&gt;
&lt;li&gt;전개연산자는 각 배열의 항목들을 분리하여 가져오는 기능이다. 대괄호([])안에서 특정 배열을 전개연산자와 함께 쓰면 특정 배열의 항목들의 사본들로 구성된 새로운 배열을 반환한다. 전개연산자 개념만 알면 조작(추가/삭제/수정)을 위한 여러 배열 메소드를 기억할 필요 없다(과장하면 전개연산자가 만능키 역할을 한다).변경된 위치가 시각적으로 잘 보여주기 때문에 배열 메소드를 사용한 것보다 직관적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[첫 블로그]]></title><description><![CDATA[개인 블로그 만든 계기 작년에 부트캠프를 다니면서 매주 하나씩 velog에 TWIL을 올렸다.
처음엔 짜집거나 베끼기 정도로 그쳤지만 갈수록 내 말로 풀어서 작성하게 되었다. 글 한 편을 쓰는 데…]]></description><link>https://pjaeyoung.github.io/challenge30/첫-블로그-/</link><guid isPermaLink="false">https://pjaeyoung.github.io/challenge30/첫-블로그-/</guid><pubDate>Tue, 02 Feb 2021 13:02:39 GMT</pubDate><content:encoded>&lt;h3 id=&quot;개인-블로그-만든-계기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B0%9C%EC%9D%B8-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A0-%EA%B3%84%EA%B8%B0&quot; aria-label=&quot;개인 블로그 만든 계기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;개인 블로그 만든 계기&lt;/h3&gt;
&lt;p&gt;작년에 부트캠프를 다니면서 매주 하나씩 velog에 TWIL을 올렸다.
처음엔 짜집거나 베끼기 정도로 그쳤지만 갈수록 내 말로 풀어서 작성하게 되었다. 글 한 편을 쓰는 데 5시간 이상이나 걸렸지만 개념을 단단하게 잡고 간다는 게 느껴졌고 부트캠프가 끝날 때까지 지속적으로 블로깅을 할 수 있었다.&lt;/p&gt;
&lt;p&gt;하지만, 취업 후 바쁘다는 핑계로 블로그를 안 하게 되었다. 당장 눈 앞에 놓인 문제를 해결하느라 여기저기 흩어진 정보를 꾸역꾸역 머릿속에 넣기만 했다. 천천히 음미하여 먹지 못한 지식들은 제대로 소화되지 못한 채 장에 쌓여 탈이 나버렸다.&lt;/p&gt;
&lt;p&gt;나는 누구보다 콧대가 높아야 한다 생각했다. 기본기도 제대로 다지지 않은 상태에서 더 세련된 코드, 멋진 코드를 짜고 싶다는 생각에 사로잡혔다. 여기저기서 주어들은 팁들을 긴 고민 없이 가져다 쓰니 코드가 점점 엉망진창이었다. 퇴사 전 인수인계를 위해 문서화 작업을 하면서 &lt;strong&gt;다른 사람이 이해할 수 있는 코드&lt;/strong&gt; 를 작성하지 못하고 &lt;strong&gt;나만 아는 코드&lt;/strong&gt;를 작성했음을 깨달았다. &lt;strong&gt;기본에 충실하며 조금씩 다듬어가는 과정&lt;/strong&gt;에 익숙해지기 위해 다시 블로깅을 할 마음이 생겼다.&lt;/p&gt;
&lt;p&gt;개발자는 혼자서 개발하는 것이 아니다. 첫 입사 후 한달 정도는 이것저것 묻고 얘기하면서 작업을 했다. 점차 입을 닫고 등을 돌려 작업을 하다보니 프로젝트에 대해 서로 생각한 바가 달라 수정사항이 발생하고 개발 일정에 차질이 생겼다. 열심히 만들어 놓고 다시 수정하는 일이 반복되다보니 의욕이 사라졌다. 얼마 전 들었던 &lt;a href=&quot;https://event-us.kr/FKH3nHkjmPGh/event/28118?state=1&quot;&gt;데브그라운드(한빛미디어 주최 개발강연)&lt;/a&gt; 에서 &lt;strong&gt;회의시간 외에 일상적으로 지속적인 교류&lt;/strong&gt;가 필요하다는 말이 와닿았다.&lt;/p&gt;
&lt;p&gt;소통할 줄 아는 개발자가 되기 위한 첫 걸음은 생각을 정리하고 표현하는 글쓰기라 생각한다. 내가 어떤 사고과정에서 이런 결론에 도달했는지 글로 정리하면 자연스럽게 대화로도 이어진다.&lt;/p&gt;
&lt;p&gt;그래서, 앞으로 블로그를 아래와 같이 진행할 예정이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;블로깅-진행-방식&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B8%94%EB%A1%9C%EA%B9%85-%EC%A7%84%ED%96%89-%EB%B0%A9%EC%8B%9D&quot; aria-label=&quot;블로깅 진행 방식 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;블로깅 진행 방식&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;30일간 매일 작성한다. ( 30일 챌린지를 통해 글쓰기의 거부감을 없앤다.)&lt;/li&gt;
&lt;li&gt;블로깅에 쓸 내용은 복습,프로젝트 진행과정, 문제해결과정, 개발 서적 및 강의 정리로 구성된다. (일상 글이나 개발 외적인 글은 30일 챌린지에 포함하지 않는다.)&lt;/li&gt;
&lt;li&gt;블로깅할 때 가장 중요한 점은 &lt;strong&gt;보지않고 작성하기&lt;/strong&gt; 이다. 내 말로 풀어쓰는 방법 중에 최고다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;br/&gt;
&lt;br/&gt;
깜빡 잊고 소제목에 대한 설명을 언급하지 않았다. 
왜 있던 velog는 놔두고 개인 블로그를 사용하는가? velog도 딱히 찾아오는 이는 드물다. 보는 이가 적지만 언제든지 노출이 될 가능성이 있다는 점이 마음에 걸렸다. 아직은 내가 쓴 글이 남들에게 보여주기 민망하다고 느끼기 때문에 누가 억지로 내 블로그 링크를 누르지 않는 한 볼 수 없는 조금은 폐쇄적인 개인 블로그에서 글쓰기에 적응하고자 개인 블로그를 만들었다.
&lt;br/&gt;
&lt;br/&gt;
&lt;p&gt;개인 블로그는 한재엽님께서 만들어주신 &lt;a href=&quot;https://github.com/JaeYeopHan/gatsby-starter-bee&quot;&gt;gatsby-starter-bee&lt;/a&gt; 를 바탕으로 손쉽게 만들었다. ‘손쉽게라고 말했지만 처음에 많이 헤맸다. 깃헙페이지로 분명 올렸는데 계속 깃헙 README.md 만 보였다. 알고보니 gatsby-meta-config.js에서 siteUrl을 내 깃헙 url로 변경하지 않았기 때문이었다. 중간 중간 cache나 public 폴더를 삭제하지 않으면 gatsby-meta-config나 styles 수정 사항이 반영되지 않은 경우가 있으니 새로 글을 작성하면 이전 거는 지우고 deploy를 진행해야 했다. velog할 때보다 좀 불편한데(발행 시간 즉 deploy 시간이 길다) 이것도 금방 적응하겠지 하고 첫 블로그 글을 마무리한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[about]]></title><description><![CDATA[Your name Thank you for reading my resume. If you want to contact me, Please send me an email.]]></description><link>https://pjaeyoung.github.io/resume-en/</link><guid isPermaLink="false">https://pjaeyoung.github.io/resume-en/</guid><pubDate>Sun, 27 Jan 2019 16:21:13 GMT</pubDate><content:encoded>&lt;h1 id=&quot;your-name&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#your-name&quot; aria-label=&quot;your name permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Your name&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;em&gt;Thank you for reading my resume. If you want to contact me, Please send me an email.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>