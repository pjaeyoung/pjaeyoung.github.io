{"componentChunkName":"component---src-templates-blog-post-js","path":"/challenge30/07/","result":{"data":{"site":{"siteMetadata":{"title":"DODO's DEV LOG","author":"dodo","siteUrl":"https://pjaeyoung.github.io","comment":{"disqusShortName":"dodo","utterances":"pjaeyoung/dodo-blog"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"7a8d1d84-f111-56f7-bdbf-cdb1076e2e35","excerpt":"<자바스크립트 코딩의 기술> 요약 정리 08장 클래스로 인터페이스를 간결하게 유지하라  es6부터 지원되는 클래스는 전혀 새로운 문법이 아니라 기존의 프로토타입으로 속성과 메서드를 상속하는 방식을 다른 객체 지향 언어의 클래스 형식을 차용한 문법이다. 다만 자바스크립트의 독특한 this의 성질은 남아있기 때문에 주의해야 한다.  클래스의 constructor 함수는 생성자 함수 역할을 한다. constructor 함수 안에서 속성을 추가한다. 현재까지 자바스크립트는 공식적으로 private…","html":"<h3 id=\"자바스크립트-코딩의-기술-요약-정리\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%BD%94%EB%94%A9%EC%9D%98-%EA%B8%B0%EC%88%A0-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC\" aria-label=\"자바스크립트 코딩의 기술 요약 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>&#x3C;자바스크립트 코딩의 기술> 요약 정리</h3>\n<ul>\n<li>\n<p>08장 클래스로 인터페이스를 간결하게 유지하라 </p>\n<ul>\n<li>es6부터 지원되는 클래스는 전혀 새로운 문법이 아니라 기존의 프로토타입으로 속성과 메서드를 상속하는 방식을 다른 객체 지향 언어의 클래스 형식을 차용한 문법이다. 다만 자바스크립트의 독특한 this의 성질은 남아있기 때문에 주의해야 한다. </li>\n<li>\n<p>클래스의 constructor 함수는 생성자 함수 역할을 한다. constructor 함수 안에서 속성을 추가한다.</p>\n<ul>\n<li>현재까지 자바스크립트는 공식적으로 private 속성을 지원하지 않는다. 어디서든 속성값에 곧바로 접근해서 값을 수정할 수 있다는 취약점은 원래 의도했던 데이터 형태를 훼손(가령, string이었던 속성값을 number로 변경)할 가능성으로 이어진다. </li>\n<li>private 속성 대신 컨벤션과 getter, setter 메서드로 취약점을 보완한다. 속성명 맨 앞은 언더바(_)를 적어 private한 속성임을 명시한다. 외부에서 사용할 때는 동일한 이름의 get, set 메서드 형식으로 표현한다. 클래스 내부는 메서드 형식이지만 외부에서는 마치 속성처럼 접근할 수 있다. </li>\n</ul>\n</li>\n<li>\n<p>클래스의 메서드 안에서 인자로 this에 접근하는 콜백함수를 받는 함수를 실행할 때 아무 조치가 없다면 this는 객체 인스턴스가 아닌 global, window 객체를 가리킨다. this는 오직 생성자 함수와 메서드 내에서(메서드 몸체 안에 곧바로)만 인스턴스에 접근할 수 있기 때문이다. 이 경우 bind를 사용하여 this를 인스턴스로 묶어주면 된다. </p>\n<ul>\n<li>여러 메서드를 걸쳐 사용된다면 생성자 함수에서 bind로 단 한 번만 묶어준다. 혹은 화살표 함수를 사용한다. </li>\n</ul>\n</li>\n<li>제너레이터는 함수 실행을 중간에 멈추고 반환하는 함수다. 복잡한 객체 형태(중첩객체)를 순회할 때 유용하다. 클래스 메서드 형태는 <code class=\"language-text\">*[Symbol.iterator](){}</code> 이고 반복문을 사용해서 중첩 객체에 접근하는 로직을 작성한다. 외부에서는 <code class=\"language-text\">for ... of</code> 나 spread operator를 사용한 분해 할당이 가능하다.       </li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"07","date":"February 11, 2021"}}},"pageContext":{"slug":"/challenge30/07/","previous":{"fields":{"slug":"/challenge30/06/"},"frontmatter":{"title":"06","category":"challenge30","draft":false}},"next":{"fields":{"slug":"/challenge30/08/"},"frontmatter":{"title":"08","category":"challenge30","draft":false}}}},"staticQueryHashes":["3128451518","521680639"]}