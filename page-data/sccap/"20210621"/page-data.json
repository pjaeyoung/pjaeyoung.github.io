{"componentChunkName":"component---src-templates-blog-post-js","path":"/sccap/\"20210621\"/","result":{"data":{"site":{"siteMetadata":{"title":"DODO's DEV LOG","author":"dodo","siteUrl":"https://pjaeyoung.github.io","comment":{"disqusShortName":"dodo","utterances":"pjaeyoung/dodo-blog"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"c04a9dc5-9b86-5948-9598-9b73c94bfaab","excerpt":"스캡 프로젝트 개발자 회의록 작성 PM분들의 요청으로 온보딩 난이도에 대한 회의를 다른 프론트 개발자분과 함께 진행했다. 코드 복잡성을 염려하여 Tutorial 전용 스크린 폴더를 만들기로 결정했다. 기존 FOLDER 화면과 SORT 화면에서 약간만 수정하면 되기에 구현 가능한 수준으로 말씀드렸다. 코딩 FOLDER 화면 겹침 문제를 FolderSvg 컴포넌트의 position을 absolute로 바꾼 후 다시 레이아웃을 잡아서 해결했다. ScrollView…","html":"<h2 id=\"스캡-프로젝트\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BA%A1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8\" aria-label=\"스캡 프로젝트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스캡 프로젝트</h2>\n<h3 id=\"개발자-회의록-작성\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EB%B0%9C%EC%9E%90-%ED%9A%8C%EC%9D%98%EB%A1%9D-%EC%9E%91%EC%84%B1\" aria-label=\"개발자 회의록 작성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개발자 회의록 작성</h3>\n<ul>\n<li>PM분들의 요청으로 온보딩 난이도에 대한 회의를 다른 프론트 개발자분과 함께 진행했다.</li>\n<li>코드 복잡성을 염려하여 Tutorial 전용 스크린 폴더를 만들기로 결정했다.</li>\n<li>기존 FOLDER 화면과 SORT 화면에서 약간만 수정하면 되기에 구현 가능한 수준으로 말씀드렸다.</li>\n</ul>\n<h3 id=\"코딩\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%94%A9\" aria-label=\"코딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코딩</h3>\n<ul>\n<li>FOLDER 화면 겹침 문제를 FolderSvg 컴포넌트의 position을 absolute로 바꾼 후 다시 레이아웃을 잡아서 해결했다.</li>\n<li>ScrollView가 스크롤되지 않는 현상이 다시 보였으나 이부분은 Scrollable 컴포넌트의 높이를 스크린의 높이보다 크게 잡아 해결했다.</li>\n<li>새삼스럽게 부모 컴포넌트가 absolute이고 자식 컴포넌트가 absolute이면 자식 컴포넌트가 부모 컴포넌트 기준으로 top, left, right, bottom 이 움직이는 걸 알게 되었다. 무조건 가장 가까운 relative 상위 컴포넌트를 기준으로 움직인다고 생각했었는데 정정해야지.</li>\n</ul>\n<h2 id=\"react18-아티클을-읽고\" style=\"position:relative;\"><a href=\"#react18-%EC%95%84%ED%8B%B0%ED%81%B4%EC%9D%84-%EC%9D%BD%EA%B3%A0\" aria-label=\"react18 아티클을 읽고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React18 아티클을 읽고</h2>\n<ul>\n<li>배치라는 용어에 대해 알게 되었다. state가 변경할 때마다, 즉 setState가 실행될 때마다 리렌더링하는 것이 아니라 setState를 한꺼번에 묶어서 처리한다는 사실은 알고 있었다. 하지만 클릭과 같은 이벤트 안에서 비동기 처리 후 setState를 하면 배치가 안 되고 setState를 할 때마다 리렌더링한다.</li>\n<li>React18부터는 어디에서 setState를 하든 상관없이 배치가 가능하다.</li>\n<li>Suspense나 startTransition 기능을 보니 비동기적으로 ui 처리하기가 한결 수월해질 것 같다. 직접 데이터 요청을 했는지 안 했는지에 대한 상태 변경을 했었는데 이부분을 알아서 처리해준다.</li>\n</ul>","frontmatter":{"title":"20210621","date":"June 21, 2021"}}},"pageContext":{"slug":"/sccap/\"20210621\"/","previous":{"fields":{"slug":"/sccap/\"20210618\"/"},"frontmatter":{"title":"20210618","category":"TIL","draft":false}},"next":{"fields":{"slug":"/sccap/\"20210622\"/"},"frontmatter":{"title":"20210622","category":"TIL","draft":false}}}},"staticQueryHashes":["3128451518","521680639"]}